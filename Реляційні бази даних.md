# Частина 1: Теоретичний вступ до реляційних баз даних

## 1.1. Що таке база даних (БД)? 

**База даних** — це організована колекція структурованої інформації, або даних, яка зберігається в електронному вигляді в комп'ютерній системі. Головна мета БД — ефективне зберігання, оновлення, видалення та надання доступу до великих обсягів даних.

Це як електронна шафа для документів, яка не просто зберігає інформацію, а й вміє її швидко знаходити, сортувати, фільтрувати та зв'язувати між собою за заданими правилами.

| Критерій | Звичайна таблиця (Excel) | База Даних (PostgreSQL) |
| :--- | :--- | :--- |
| **Обсяг даних** | Обмежений, сповільнюється на великих файлах | Створена для мільйонів/мільярдів записів |
| **Багатокористувацький доступ**| Проблематичний, ризик конфліктів | Одночасна робота багатьох користувачів |
| **Цілісність даних** | Легко внести помилку (напр., текст у числове поле) | Суворі правила та типи даних |
| **Безпека** | Обмежена (пароль на файл) | Гнучкі права доступу для різних користувачів |
| **Швидкість запитів**| Повільний пошук на великих даних | Висока швидкість завдяки індексам |

---

## 1.2. Модель "клієнт-сервер"

Робота з сучасними базами даних майже завжди відбувається за моделлю **клієнт-сервер**.

* **Сервер БД (Server)** 
    * Це "мозок" операції. Потужна програма (наприклад, PostgreSQL), яка безпосередньо керує фізичними файлами бази даних.
    * **Обов'язки**: зберігання даних, забезпечення їх цілісності, виконання запитів, керування доступом. Сервер працює 24/7 і чекає на команди.
* **Клієнт БД (Client)** 
    * Це будь-яка програма, яка підключається до сервера, щоб надіслати йому команду (запит) і отримати відповідь.
    * **Приклади клієнтів**:
        * **DBeaver**: графічний інструмент для адміністраторів та розробників.
        * **Веб-сайт**: серверна частина вашого сайту (напр., на Python) надсилає запити до БД.
        * **Мобільний додаток**: може опосередковано звертатися до БД через API.

**Схема роботи:** `Клієнт (DBeaver) → надсилає SQL-запит → Сервер (PostgreSQL) → виконує запит → повертає результат → Клієнт (DBeaver)`

---

## 1.3. Реляційна модель даних

**Реляційна модель** — це спосіб організації даних у вигляді набору пов'язаних таблиць. Це найпопулярніша модель у світі.

#### Ключові поняття:

* **Таблиця (Table / Relation)**: Основний об'єкт, що зберігає дані про певну сутність. Наприклад, `users` або `products`.
* **Рядок (Row / Tuple / Запис)**: Конкретний екземпляр сутності. Наприклад, один користувач з ім'ям "Іван" або один товар "Ноутбук".
* **Стовпець (Column / Атрибут)**: Характеристика сутності. Наприклад, `first_name`, `email` або `price`. Кожен стовпець має **строгий тип даних** (`INTEGER`, `TEXT` тощо).

#### Чому "реляційна"?

Назва походить від математичного терміну **"відношення" (relation)** з теорії множин, що по суті і є таблицею (множиною рядків). Тому база називається "реляційною", бо вона складається з таких "відношень".

#### Ключі для зв'язків:

* **Первинний ключ (Primary Key, PK)**: Один або кілька стовпців, значення яких **унікально ідентифікує кожен рядок** у таблиці. Не може бути порожнім (`NULL`). *Приклад: `user_id` в таблиці `users`.*
* **Зовнішній ключ (Foreign Key, FK)**: Стовпець в одній таблиці, який посилається на первинний ключ в іншій таблиці. Це і є механізм, що **створює зв'язок** між таблицями. *Приклад: `author_id` в таблиці `posts` посилається на `user_id` в таблиці `users`.*

#### Типи відносин (зв'язків):

1.  **Один-до-одного (One-to-One)**: Один запис в одній таблиці відповідає лише одному запису в іншій. *Приклад: `users` та `user_profiles`. Один юзер — один профіль.*
2.  **Один-до-багатьох (One-to-Many)**: Один запис в одній таблиці може бути пов'язаний з багатьма записами в іншій. Це найчастіший тип зв'язку. *Приклад: `users` та `posts`. Один юзер — багато постів.*
3.  **Багато-до-багатьох (Many-to-Many)**: Багато записів в одній таблиці можуть бути пов'язані з багатьма записами в іншій. Реалізується через третю, **проміжну таблицю**. *Приклад: `students` та `courses`. Один студент може відвідувати багато курсів, і один курс може мати багато студентів.*
# Частина 2: Практична підготовка до роботи 

## 2.1. Знайомство з PostgreSQL та DBeaver

Ми будемо використовувати два основні інструменти: **сервер бази даних** та **клієнт** для роботи з ним.

* **PostgreSQL (або просто "Postgres")**: Це наша **система управління базами даних (СУБД)**. Ми не будемо встановлювати її напряму, а запустимо в ізольованому середовищі за допомогою Docker.
* **DBeaver**: Це наш **універсальний графічний клієнт**. Його ми встановимо локально, щоб підключатися до нашого Postgres-контейнера.

**Аналогія:** PostgreSQL в Docker — це двигун в ідеально налаштованому боксі, а DBeaver — це приладова панель та кермо, за допомогою яких ми цим двигуном керуємо.

---

## 2.2. Підготовка середовища за допомогою Docker

Замість локальної інсталяції ми використаємо Docker, щоб швидко розгорнути чистий екземпляр PostgreSQL. Це швидше, надійніше і не засмічує вашу операційну систему.

#### Крок 1: Встановлення Docker

Якщо у вас ще не встановлено Docker, завантажте **Docker Desktop** з [офіційного сайту](https://www.docker.com/products/docker-desktop/) та встановіть його, дотримуючись інструкцій для вашої ОС.

#### Крок 2: Запуск контейнера PostgreSQL

1.  Відкрийте термінал (командний рядок, PowerShell, або термінал у вашому IDE).
2.  Виконайте наступну команду. Вона завантажить офіційний образ PostgreSQL і запустить його в контейнері:

    ```bash
    docker run --name lecture-postgres -e POSTGRES_PASSWORD=mysecretpassword -p 5432:5432 -d postgres
    ```

Давайте розберемо цю команду:
* `docker run`: Команда для запуску нового контейнера.
* `--name lecture-postgres`: Даємо нашому контейнеру зрозуміле ім'я.
* `-e POSTGRES_PASSWORD=mysecretpassword`: **(Дуже важливо!)** Ми встановлюємо змінну середовища `POSTGRES_PASSWORD`. Це буде пароль для суперкористувача `postgres`. Ви можете змінити `mysecretpassword` на будь-який інший.
* `-p 5432:5432`: Ми "прокидаємо" порт. Перше число — порт на вашому комп'ютері, друге — порт всередині контейнера. Це дозволить DBeaver з вашої машини "достукатися" до PostgreSQL у контейнері.
* `-d`: Запускає контейнер у фоновому режимі (detached mode).
* `postgres`: Назва офіційного образу, який Docker має завантажити та запустити.


### PSQL

```
docker exec -it ім'я_вашого_контейнера psql -U postgres
```


#### Крок 3: Встановлення DBeaver

1.  Перейдіть на [офіційний сайт DBeaver](https://dbeaver.io/download/).
2.  Завантажте та встановіть версію **Community Edition**.

---

## 2.3. Створення першого з'єднання та огляд інтерфейсу

Тепер з'єднаємо DBeaver з нашим PostgreSQL у Docker-контейнері.

1.  Запустіть DBeaver.
2.  Натисніть на іконку **"Нове з'єднання"** (розетка з плюсом).
3.  У вікні вибору драйвера оберіть `PostgreSQL`.
4.  Заповніть налаштування з'єднання:
    * **Host**: `localhost`
    * **Database**: `postgres`
    * **Ім'я користувача**: `postgres`
	    * **Пароль**: `mysecretpassword` (або той, який ви вказали в команді `docker run`).
5.  Натисніть кнопку **"Test Connection..."**. Ви повинні побачити повідомлення про успішне підключення.
6.  Натисніть "Готово". Нове з'єднання з'явиться у панелі "Навігатор баз даних".

#### Короткий огляд інтерфейсу DBeaver:

* **Навігатор баз даних (ліва панель)**: Ієрархія ваших підключень, баз даних, схем та таблиць.
* **Редактор SQL (центральна панель)**: Ваша основна робоча область для написання запитів.
* **Панель результатів (нижня панель)**: Місце, де з'являються результати виконання запитів.


# Частина 3: Основи мови SQL 

**SQL (Structured Query Language)** — це декларативна мова, що використовується для взаємодії з реляційними базами даних. "Декларативна" означає, що ми описуємо, **ЩО** ми хочемо отримати, а не **ЯК** це зробити. СУБД сама визначає найефективніший шлях для виконання нашого запиту.

### 3.1. Категорії команд SQL

Усі SQL-команди можна розділити на кілька основних груп. Ми зосередимось на перших трьох:

* **DDL (Data Definition Language)** — мова визначення даних. Команди для створення та управління структурою об'єктів БД.
    * `CREATE` (створити), `ALTER` (змінити), `DROP` (видалити).
* **DML (Data Manipulation Language)** — мова маніпуляції даними. Команди для роботи безпосередньо з рядками в таблицях.
    * `INSERT` (вставити), `UPDATE` (оновити), `DELETE` (видалити).
* **DQL (Data Query Language)** — мова запитів даних. Використовується для вибірки даних. По суті, це лише одна, але найважливіша команда.
    * `SELECT` (вибрати).

---

### 3.2. Створення та управління таблицями (DDL)

DDL-команди дозволяють нам будувати "скелет" нашої бази даних.

#### `CREATE TABLE`

Створює нову таблицю з заданими стовпцями та їх типами даних.

**Основні типи даних в PostgreSQL:**
* `SERIAL` або `BIGSERIAL`: Автоінкрементне ціле число. Ідеально для `PRIMARY KEY`.
* `INTEGER` або `INT`: Ціле число.
* `VARCHAR(n)`: Текст обмеженої довжини (n - максимальна кількість символів).
* `TEXT`: Текст необмеженої довжини.
* `BOOLEAN`: Значення `true` або `false`.
* `TIMESTAMP`: Мітка часу (дата + час).

**Приклад:** Створимо таблицю для користувачів.

```sql
CREATE TABLE users (
    id SERIAL PRIMARY KEY,
    username VARCHAR(50) UNIQUE NOT NULL,
    email VARCHAR(100) UNIQUE NOT NULL,
    is_active BOOLEAN DEFAULT true,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
````

- `PRIMARY KEY` робить стовпець `id` первинним ключем.
- `UNIQUE` гарантує, що значення в цьому стовпці не будуть повторюватися.
- `NOT NULL` забороняє порожні значення.
- `DEFAULT` встановлює значення за замовчуванням, якщо воно не вказане.

#### `ALTER TABLE` та `DROP TABLE`

- `ALTER TABLE` змінює існуючу структуру таблиці.
    ```
    -- Додаємо новий стовпець
    ALTER TABLE users ADD COLUMN bio TEXT;
    ```
- `DROP TABLE` повністю видаляє таблицю та всі її дані **(ОБЕРЕЖНО!)**.

  ```   
   DROP TABLE users;
   ```

```SQL

ALTER TABLE users ADD COLUMN IF NOT EXISTS bio TEXT;

-- test data
INSERT INTO users (name, email, bio) VALUES

('john_doe', 'john.doe@domain.ua', 'Розробник програмного забезпечення з Києва.'),

('jane_smith', 'jane.smith@gmail.com', 'Графічний дизайнер, захоплююся фотографією.'),

('mike_jones', 'mike.j@yahoo.com', 'Менеджер проектів з 10-річним досвідом.'),

('alice_williams', 'alice.w@outlook.com', 'Студентка, вивчаю комп''ютерні науки у Львові.'),

('bob_brown', 'b.brown@gmail.com', 'Аналітик даних, люблю подорожувати.'),

('charlie_davis', 'charlie@gmail.net', 'Інженер-механік, працюю над інноваційними проектами.'),

('diana_miller', 'diana.miller@domain.ua', 'Волонтерка та громадська активістка.'),

('eva_wilson', 'eva.w@domain.ua', 'Художниця, створюю абстрактні картини.'),

('frank_moore', 'frank.moore@gmail.com', 'Письменник та автор науково-фантастичних оповідань.'),

('grace_taylor', 'grace.t@domain.ua', 'Маркетолог, спеціалізуюся на цифровому просуванні.');
```
---

### 3.3. Робота з даними (DML)

DML-команди наповнюють наші таблиці життям (даними) і дозволяють їх змінювати.

#### `INSERT INTO`

Додає один або декілька нових рядків у таблицю.

```
-- Додавання одного користувача
INSERT INTO users (username, email) VALUES ('john_doe', 'john.doe@example.com');

-- Додавання кількох користувачів одразу
INSERT INTO users (username, email) VALUES
('jane_doe', 'jane.doe@example.com'),
('admin_user', 'admin@example.com');
```

#### `UPDATE`

Змінює дані в існуючих рядках. **Завжди використовуйте `WHERE`**, інакше ви зміните дані **в усіх рядках** таблиці!

```
-- Оновлюємо біографію конкретного користувача
UPDATE users
SET bio = 'A passionate software developer.'
WHERE username = 'john_doe';
```

#### `DELETE`

Видаляє рядки з таблиці. **Завжди використовуйте `WHERE`**, інакше ви видалите **всі дані** з таблиці!


```
-- Видаляємо користувача за його email
DELETE FROM users
WHERE email = 'jane.doe@example.com';
```

---

### 3.4. Вибірка даних (DQL)

`SELECT` — це найчастіше використовувана команда в SQL. Вона дозволяє "запитувати" дані з бази.

#### `SELECT ... FROM`

Отримує дані з однієї або кількох таблиць.


```
-- Вибрати всі стовпці з таблиці users
SELECT * FROM users;

-- Вибрати лише конкретні стовпці
SELECT username, email FROM users;
```

#### `WHERE`

Фільтрує результати за певною умовою.


```
-- Знайти активних користувачів
SELECT * FROM users WHERE is_active = true;

-- Знайти користувача за іменем (точне співпадіння)
SELECT * FROM users WHERE username = 'admin_user';

-- Знайти користувачів, чий email закінчується на @example.com
SELECT * FROM users WHERE email LIKE '%@example.com';
```

#### `ORDER BY` та `LIMIT`
- `ORDER BY` сортує результат за одним або кількома стовпцями.
- `LIMIT` обмежує кількість рядків у результаті.

```
-- Вибрати всіх користувачів, відсортованих за іменем в алфавітному порядку
SELECT username, email FROM users ORDER BY username ASC;

-- Вибрати 5 найновіших користувачів
SELECT * FROM users ORDER BY created_at DESC LIMIT 5;
```

### **Частина 4: Поглиблені техніки SQL **

---

#### **4.1. Агрегатні функції для аналізу даних**

Агрегатні функції виконують обчислення на наборі значень і повертають єдиний результат. Вони незамінні для аналітики.

- `COUNT(* | column)`: Рахує кількість рядків.
- `SUM(column)`: Обчислює суму значень.
- `AVG(column)`: Обчислює середнє значення.
- `MIN(column)` / `MAX(column)`: Знаходять мінімальне / максимальне значення.

**`GROUP BY` та `HAVING`**
- **`GROUP BY`** групує рядки з однаковими значеннями для застосування агрегатних функцій до кожної групи окремо.
- **`HAVING`** фільтрує результат **після** групування. На відміну від `WHERE`, яке фільтрує рядки **до** групування.

**Приклад**: Порахувати, скільки користувачів зареєстровано з кожного поштового домену, і показати тільки ті домени, де більше одного користувача.

```SQL
SELECT
    SUBSTRING(email FROM '@(.*)$') AS domain, -- Витягуємо домен
    COUNT(*) AS user_count
FROM
    users
GROUP BY
    domain -- Групуємо за доменом
HAVING
    COUNT(*) > 1 -- Фільтруємо групи
ORDER BY
    user_count DESC;
```

---


### **4.2. Математичний апарат: від теорії множин до JOIN'ів 

Щоб по-справжньому зрозуміти, як і чому працюють об'єднання таблиць (`JOIN`), потрібно зазирнути в математику, яка лежить в їх основі. Реляційна модель не була вигадана з нуля — вона базується на розділі математики під назвою **теорія множин** та **реляційній алгебрі**.

Уявіть, що кожна таблиця у вашій базі даних — це **множина** (a set). А кожен рядок у цій таблиці — це **елемент** цієї множини.

Наприклад, `Таблиця Users` — це `Множина A`, `Таблиця Posts` — це `Множина B`.

---

#### **Операції над множинами як основа для SQL**

Давайте розглянемо базові операції над множинами за допомогою діаграм Ейлера-Венна і відразу проведемо паралелі з SQL.

- ### **Перетин (Intersection)**
**Що це?** Перетин двох множин (`A ∩ B`) — це нова множина, яка містить лише ті елементи, що знаходяться **одночасно в обох** початкових множинах. Це їхня спільна частина.
**Зв'язок з SQL:** Це і є концептуальна основа **`INNER JOIN`**. Коли ми об'єднуємо таблиці `Users` і `Posts` за `user_id`, ми фактично просимо базу даних: "дай мені лише ті пари (користувач, пост), де користувач із першої таблиці є автором поста з другої". Ми шукаємо збіги, тобто **перетин** за ключем.

- ### **Різниця (Difference)**

**Що це?** Різниця множин (`A \ B`) — це нова множина, яка містить елементи, що є в першій множині (`A`), але яких **немає** в другій (`B`).
**Зв'язок з SQL:** Ця концепція ідеально пояснює роботу **`LEFT JOIN` з фільтрацією `WHERE ... IS NULL`**.
1. `LEFT JOIN` бере **всі** елементи з лівої множини (таблиці `Users`).
2. Потім він намагається знайти для них відповідники у правій множині (таблиці `Posts`).
3. Якщо ми додамо умову `WHERE posts.id IS NULL`, ми відфільтруємо всі збіги і залишимо лише елементи з лівої множини, для яких не знайшлося пари. Тобто, ми знайдемо користувачів, які не написали жодного поста — це і є **різниця** множин.

- ### **Об'єднання (Union)**
**Що це?** Об'єднання множин (`A U B`) — це нова множина, що містить **усі** елементи, які є хоча б в одній з початкових множин, причому дублікати усуваються.

**Зв'язок з SQL:** Для цього в SQL існує прямий відповідник — оператор **`UNION`**. Він дозволяє об'єднати результати двох `SELECT` запитів в одну фінальну таблицю.

---

#### **Реляційна алгебра: Мова запитів до винаходу SQL**

**Реляційна алгебра** — це формальний набір операцій для роботи з таблицями (відношеннями). SQL — це, по суті, комерційна та більш дружня до користувача реалізація цих операцій.

- **Проекція (π)**: Це операція вибору **стовпців**. Коли ви пишете `SELECT name, email FROM users`, ви виконуєте проекцію атрибутів `name` та `email` з відношення `users`.
- **Селекція (σ)**: Це операція фільтрації **рядків** на основі певної умови. Коли ви пишете `WHERE is_active = true`, ви виконуєте селекцію кортежів (рядків), які задовольняють цю умову.
- **З'єднання (⨝)**: Це фундаментальна операція, яка комбінує відношення. `INNER JOIN`, `LEFT JOIN` в SQL є різновидами цієї операції.
 
**Висновок**: Розуміння цих простих математичних концепцій перетворює SQL із "магічних заклинань" на логічний та зрозумілий інструмент для роботи з даними. `JOIN` — це не щось складне, а лише практична реалізація ідеї пошуку спільних елементів між множинами даних.


#### **4.3. Об'єднання таблиць (`JOIN`)**

`JOIN` — це ключова операція, що дозволяє комбінувати рядки з різних таблиць.

Спочатку створимо таблицю `posts` зі зв'язком до `users`:

``` SQL
CREATE TABLE posts (
    id SERIAL PRIMARY KEY,
    user_id INTEGER NOT NULL,
    title VARCHAR(200) NOT NULL,
    CONSTRAINT fk_user
        FOREIGN KEY(user_id) 
        REFERENCES users(id)
        ON DELETE CASCADE -- Якщо видалити юзера, його пости теж видаляться
);

INSERT INTO posts (user_id, title) VALUES (1, 'My first post!'), (3, 'Docker tips');
```

- **`INNER JOIN`** (Внутрішнє з'єднання): Повертає лише ті рядки, для яких знайшовся збіг в обох таблицях.

  ```sql
   -- Вибрати пости та імена їхніх авторів
   SELECT p.title, u.name
   FROM posts AS p
   INNER JOIN users AS u ON p.user_id = u.id;
   ```
- **`LEFT JOIN`** (Ліве зовнішнє з'єднання): Повертає **всі** рядки з лівої таблиці і відповідні їм рядки з правої. Якщо відповідника немає, стовпці з правої таблиці будуть `NULL`
 ```sql
   -- Вибрати ВСІХ користувачів та кількість їхніх постів (навіть якщо 0)
   SELECT u.name, COUNT(p.id) AS post_count
   FROM users AS u
   LEFT JOIN posts AS p ON u.id = p.user_id
   GROUP BY u.name
   ORDER BY post_count DESC;
   ```

---

#### **4.4. Вкладені запити та псевдоніми (Aliases)**

- **Псевдонім (Alias)** — це тимчасове ім'я для таблиці або стовпця, що задається за допомогою `AS`. Ми вже використовували їх вище (`p` для `posts`, `u` для `users`).

- **Вкладений запит (Subquery)** — це `SELECT`-запит, вкладений всередину іншого запиту.
 ```sql
   -- Знайти всіх користувачів, які написали хоча б один пост
   SELECT name FROM users
   WHERE id IN (SELECT DISTINCT user_id FROM posts);
   ```

---
#### **4.5. Оптимізація: Індекси та Обмеження (`Constraints`)**

- **Обмеження (Constraints)**: Це правила, що гарантують цілісність даних. Ми їх вже бачили:
- `PRIMARY KEY`: Унікальний ідентифікатор рядка.
- `FOREIGN KEY`: Забезпечує зв'язок між таблицями.
- `UNIQUE`: Гарантує унікальність значень у стовпці.
- `NOT NULL`: Забороняє порожні значення.
- `CHECK`: Перевіряє, чи значення відповідає умові (`CHECK (price > 0)`).

- **Індекси (`INDEX`)**: Це спеціальна структура даних, що дозволяє СУБД знаходити рядки набагато швидше.

- **Аналогія**: Як алфавітний покажчик у кінці книги. Замість того, щоб гортати всю книгу, ви дивитесь в покажчик і одразу знаходите потрібну сторінку.

- Індекси значно прискорюють операції `SELECT` з умовою `WHERE`, але трохи сповільнюють `INSERT` та `UPDATE`, оскільки індекс теж потрібно оновлювати.
  ```
  -- Створити індекс для стовпця username для пришвидшення пошуку по ньому
   CREATE INDEX idx_users_username ON users(username);
   ```


#### 4.6 **Теорія нормалізації реляційних баз даних**

---

#### **Вступ**

**Нормалізація** є фундаментальним процесом у проєктуванні реляційних баз даних, метою якого є організація атрибутів та відношень для мінімізації надлишковості даних та підвищення їхньої цілісності. Процес полягає у послідовному застосуванні правил, відомих як **нормальні форми**, що призводить до декомпозиції таблиць на менші, логічно пов'язані структури. Кінцевою метою є усунення небажаних аномалій при маніпуляції даними та створення стабільної, масштабованої схеми даних.

---

#### **Аномалії маніпуляції даними**

Недостатньо нормалізована структура даних є вразливою до трьох основних типів аномалій:

1. **Аномалія вставки (Insertion Anomaly):** Виникає, коли неможливо додати до бази даних інформацію про один об'єкт без додавання інформації про інший, пов'язаний з ним об'єкт. Наприклад, неможливість зареєструвати нового студента, доки він не буде записаний на певний курс.
2. **Аномалія оновлення (Update Anomaly):** Проявляється у необхідності оновлювати одні й ті ж самі дані у кількох кортежах. Це призводить до надлишкових операцій та створює ризик виникнення суперечностей у даних, якщо хоча б одну операцію оновлення буде пропущено.
3. **Аномалія видалення (Deletion Anomaly):** Виникає, коли видалення певних даних призводить до ненавмисної втрати інших, не пов'язаних напряму даних. Наприклад, видалення запису про єдиний курс, який відвідує студент, може призвести до повного видалення інформації про цього студента з бази даних.

---
#### **Перша нормальна форма (1NF)**

Відношення перебуває у першій нормальній формі, якщо домени всіх його атрибутів містять лише **атомарні (неподільні) значення**.

**Вимога:** Кожен атрибут повинен мати єдине значення, а не множину чи список значень.

**Приклад:**

*Ненормалізоване відношення:*

| student_id | name | courses                      |
|------------|------|------------------------------|
| 1          | Іван | {"Математика", "Фізика"}     |

*Відношення у 1NF:*

| student_id | name | course     |
|------------|------|------------|
| 1          | Іван | Математика |
| 1          | Іван | Фізика     |

Перша нормальна форма є обов'язковою умовою для реляційної моделі даних.

---

#### **Друга нормальна форма (2NF)**

Відношення перебуває у другій нормальній формі, якщо воно задовольняє умови 1NF і кожен неключовий атрибут **функціонально повно залежить** від первинного ключа.

**Вимога:** Усунення часткових залежностей, коли неключовий атрибут залежить лише від частини складеного первинного ключа. Це правило є релевантним виключно для відношень зі складеними первинними ключами.

**Приклад:**

*Відношення в 1NF (але не в 2NF) з первинним ключем `(student_id, course_id)`*:

| student_id | course_id | student_name    | grade |
|------------|-----------|-----------------|-------|
| 101        | CS101     | Іван Петренко   | 95    |
| 101        | MA203     | Іван Петренко   | 88    |

> Атрибут `student_name` частково залежить від `student_id`, що є порушенням.

*Відношення у 2NF (після декомпозиції):*

**Таблиця `Students`:**

| student_id (PK) | student_name    |
|------------------|-----------------|
| 101              | Іван Петренко   |

**Таблиця `Grades`:**

| student_id (FK) | course_id (FK) | grade |
|------------------|----------------|-------|
| 101              | CS101          | 95    |
| 101              | MA203          | 88    |

---

#### **Третя нормальна форма (3NF)**

Відношення перебуває у третій нормальній формі, якщо воно задовольняє умови 2NF і кожен його неключовий атрибут **нетранзитивно залежить** від первинного ключа.

**Вимога:** Усунення транзитивних залежностей, коли неключовий атрибут функціонально залежить від іншого неключового атрибута.

**Приклад:**

*Відношення в 2NF (але не в 3NF) з первинним ключем `course_id`:*

| course_id | course_name              | instructor_name   | instructor_email     |
|-----------|--------------------------|--------------------|-----------------------|
| CS101     | Вступ до програмування   | Проф. Ковальчук    | kovalchuk@uni.ua     |

> Тут існує транзитивна залежність: `course_id` → `instructor_name` → `in

### **Форма Бойса-Кодда (BCNF або 3.5НФ)**

Форма Бойса-Кодда (BCNF) є посиленою версією третьої нормальної форми. Хоча більшість відношень, що знаходяться у 3НФ, автоматично задовольняють і BCNF, існують рідкісні випадки, коли 3НФ є недостатньою для усунення всіх аномалій надлишковості.

**Вимоги:**

1. Відношення повинно бути у 3НФ.  
2. Для **кожної** нетривіальної функціональної залежності `X → Y`, детермінант `X` повинен бути **суперключем**.

**Що таке суперключ?**  
Це будь-яка множина атрибутів, яка унікально ідентифікує кортеж (рядок). Первинний ключ є мінімальним суперключем.

**Ключова відмінність від 3НФ:**  
3НФ дозволяє залежність `X → Y`, де `X` не є суперключем, за умови, що `Y` є частиною кандидатного ключа. BCNF закриває цю "лазівку" і вимагає, щоб детермінант *завжди* був суперключем.

#### **Класичний приклад**

Уявімо, що ми зберігаємо інформацію про те, який викладач веде який предмет у якого студента.

**Припущення:**

- Один викладач може навчати лише один предмет.  
- Кожен предмет може викладатися кількома викладачами.  
- Кожен студент для конкретного предмету має лише одного викладача.

**Відношення `Student_Subject_Instructor` (не в BCNF):**

| student | subject | instructor       |
|---------|---------|------------------|
| Іван    | Фізика  | Проф. Ковальчук  |
| Марія   | Фізика  | Проф. Ткаченко   |
| Іван    | Хімія   | Проф. Саєнко     |

**Аналіз залежностей:**

1. `(student, subject) → instructor`  
2. `instructor → subject`

**Кандидатні ключі:**

- `(student, subject)`  
- `(student, instructor)`

**Чому це в 3НФ?**  
Залежність `instructor → subject` не порушує 3НФ, бо `subject` є частиною кандидатного ключа `(student, subject)`.

**Чому це НЕ в BCNF?**  
`instructor` не є суперключем. Отже, `instructor → subject` порушує вимоги BCNF. Це створює надлишковість.

**Декомпозиція для досягнення BCNF:**

**Таблиця `Student_Instructor`:**

| student | instructor      |
|---------|-----------------|
| Іван    | Проф. Ковальчук |
| Марія   | Проф. Ткаченко  |
| Іван    | Проф. Саєнко    |

**Таблиця `Instructor_Subject`:**

| instructor       | subject |
|------------------|---------|
| Проф. Ковальчук  | Фізика  |
| Проф. Ткаченко   | Фізика  |
| Проф. Саєнко     | Хімія   |

---


### **Стан нормалізації в проектах з ORM (на прикладі Django)**

У проектах з ORM, таких як Django, структура бази даних тісно пов’язана з об’єктною моделлю коду, що впливає на рівень нормалізації.

**Зазвичай проект на Django за замовчуванням прагне до 3НФ.**

#### Чому:

**1. Одна модель — одна логічна сутність (1НФ, 2НФ):**  
Django заохочує створення окремих моделей для кожної сутності:

```python
class Student(models.Model):
    name = models.CharField(...)
```


Це забезпечує атомарність (1НФ) і повну залежність атрибутів від первинного ключа (2НФ).

2. **ForeignKey та ManyToManyField як інструменти 3НФ:**
Django реалізує транзитивні залежності через зв’язки між таблицями:

class Instructor(models.Model):
    name = models.CharField(max_length=100)
    email = models.EmailField()

class Course(models.Model):
    title = models.CharField(max_length=200)
    instructor = models.ForeignKey(Instructor, on_delete=models.SET_NULL, null=True)

Це відповідає 3НФ.
Коли відбувається відхід від нормалізації?

У практиці часто застосовують свідому денормалізацію задля продуктивності:

    Кешування обчислюваних значень:
    Наприклад, поле post_count у моделі User замість підрахунку COUNT(*) на льоту.

    Пошукові системи:
    Індекси для Elasticsearch або інших пошукових систем часто містять денормалізовані дані з кількох моделей.

Висновок

Проекти на Django ORM із коробки формують добре нормалізовану базу (до 3НФ). Всі відхилення зазвичай є усвідомленими інженерними компромісами заради швидкодії або масштабування.
---

#### **Практичні аспекти: Нормалізація та Денормалізація**

Рівень нормалізації, що застосовується до схеми бази даних, повинен відповідати архітектурним вимогам та характеру навантаження системи.

- **Транзакційні системи (OLTP):** Системи, орієнтовані на велику кількість коротких транзакцій (вставка, оновлення, видалення), вимагають високого рівня нормалізації (зазвичай 3NF або BCNF). Це забезпечує максимальну цілісність даних та мінімізує ризик аномалій. Недоліком є потенційне зниження продуктивності операцій читання через необхідність виконання значної кількості операцій з'єднання (`JOIN`).
    
- **Аналітичні системи (OLAP):** Системи, призначені для виконання складних аналітичних запитів над великими обсягами даних (сховища даних, системи бізнес-аналітики), часто використовують **денормалізацію**. Денормалізація — це процес навмисного додавання надлишкових даних до таблиць для зменшення кількості з'єднань та прискорення виконання запитів на вибірку. Продуктивність операцій читання тут є пріоритетом над надлишковістю даних.
    

Таким чином, вибір оптимального рівня нормалізації є компромісом між забезпеченням цілісності даних, оптимізацією операцій запису та продуктивністю операцій читання.
### **Частина 5: Транзакції та цілісність даних **

---

#### **5.1. Поняття транзакції**

Уявіть, що ви переказуєте гроші з одного банківського рахунку на інший. Ця операція складається з двох кроків:

1. Зняття грошей з рахунку А.
2. Зарахування грошей на рахунок Б.

Що станеться, якщо після першого кроку система вийде з ладу? Гроші зникнуть з рахунку А, але не з'являться на рахунку Б. Це катастрофа.

**Транзакція** — це послідовність однієї або кількох операцій з даними, яка розглядається як єдина **неподільна логічна одиниця роботи**. Або всі операції всередині транзакції виконуються успішно, або жодна з них не виконується.

У базах даних будь-який запит на зміну даних (`INSERT`, `UPDATE`, `DELETE`) автоматично виконується всередині транзакції.

---

#### **5.2. Властивості ACID – золотий стандарт надійності**

ACID — це акронім, що описує чотири ключові властивості, які гарантують надійність транзакцій у базі даних.

- **A — Atomicity (Атомарність)**
- **Принцип "Все або нічого"**. Транзакція є неподільною. Вона або повністю завершується успіхом (і всі її зміни зберігаються), або повністю скасовується, повертаючи базу даних до стану, в якому вона була до початку транзакції.

- **C — Consistency (Узгодженість)**
- **Принцип "Дані завжди коректні"**. Транзакція переводить базу даних з одного коректного стану в інший. Жодна транзакція не може порушити правила цілісності даних, встановлені в базі (наприклад, `FOREIGN KEY`, `UNIQUE` чи `CHECK` обмеження).

- **I — Isolation (Ізольованість)**
- **Принцип "Паралельні транзакції не заважають одна одній"**. Якщо декілька транзакцій виконуються одночасно, результат має бути таким самим, ніби вони виконувались послідовно, одна за одною. Одна транзакція не бачить проміжних, незафіксованих результатів іншої.

- **D — Durability (Довговічність)**

- **Принцип "Якщо система сказала 'ОК', дані збережено назавжди"**. Після того, як транзакція була успішно завершена (`COMMIT`), її зміни є постійними і не будуть втрачені навіть у випадку збою живлення, відмови обладнання чи інших системних проблем.


---

#### **5.3. Керування транзакціями в SQL**

Хоча багато операцій виконуються в авто-режимі, ми можемо керувати транзакціями вручну, щоб об'єднати кілька запитів в одну логічну одиницю.
- `BEGIN;` або `START TRANSACTION;`

- Явно починає нову транзакцію.

- `COMMIT;`
- Успішно завершує транзакцію і робить усі її зміни постійними.    
- `ROLLBACK;`
- Скасовує всі зміни, зроблені з моменту початку транзакції, і завершує її.   

**Приклад:**

Уявімо, що ми хочемо перевести користувача `john_doe` в архів, деактивувавши його профіль та додавши відповідний запис в таблицю `audit_log`. Обидві дії мають виконатись разом.

```SQL
BEGIN; -- Почали транзакцію

-- Крок 1: Деактивуємо користувача
UPDATE users SET is_active = false WHERE username = 'john_doe';

-- Крок 2: Записуємо дію в журнал аудиту
INSERT INTO audit_log (action, username) VALUES ('deactivated user', 'john_doe');

-- Якщо обидві команди виконалися без помилок, фіксуємо зміни
COMMIT;

-- Якщо б на якомусь етапі сталася помилка, ми б виконали ROLLBACK; 
-- і жодних змін у базі даних не відбулося б.
```
### **Частина 6: Інтеграція з Python **

---

#### **6.1. Навіщо використовувати Python для роботи з БД?**

Графічні клієнти, як DBeaver, чудово підходять для ручних запитів та адміністрування. Але в реальних проєктах нам потрібно автоматизувати роботу з даними. Python дозволяє:

- **Інтегрувати логіку** в веб-додатки (наприклад, реєстрація користувача на сайті).
- **Виконувати пакетну обробку** даних (наприклад, аналізувати тисячі записів)
- **Автоматизувати рутинні задачі** (наприклад, створювати щоденні звіти)


---

#### **6.2. Бібліотека `psycopg2`**

`psycopg2` — це найпопулярніший та найнадійніший "адаптер" (драйвер) для роботи з PostgreSQL у Python. Він дозволяє нашому Python-коду "спілкуватися" з сервером PostgreSQL.

**Встановлення:**

Відкрийте термінал та виконайте команду:

Bash

```
pip install psycopg2-binary
```

_Примітка: версія `-binary` простіша у встановленні, оскільки містить уже скомпільовані залежності._

---

#### **6.3. Практичний цикл роботи**

Робота з базою даних у Python завжди слідує одному й тому ж циклу:

1. **Підключитися** до бази даних.
2. Створити **курсор**.
3. **Виконати** SQL-запит.
4. **Отримати** результат (якщо потрібно).
5. **Зафіксувати** транзакцію (`commit`).
6. **Закрити** курсор та з'єднання.

**Дуже важливо** завжди закривати з'єднання, щоб звільнити ресурси.

**Приклад повного циклу:**

``` Python
import psycopg2

# Параметри підключення (використовуємо ті, що задали в docker-compose)
db_params = {
    "host": "localhost",
    "port": "5432",
    "user": "postgres",
    "password": "mysecretpassword",
    "database": "postgres"
}

conn = None
cursor = None

try:
    # 1. Підключитися до бази даних
    conn = psycopg2.connect(**db_params)
    
    # 2. Створити курсор
    # Курсор дозволяє виконувати команди в сесії БД
    cursor = conn.cursor()
    
    # 3. Виконати запит (INSERT)
    # ВАЖЛИВО: Завжди передавайте параметри через другий аргумент execute()
    # Це захищає від SQL-ін'єкцій!
    new_user = ('python_user', 'python@example.com')
    sql_insert = "INSERT INTO users (username, email) VALUES (%s, %s);"
    cursor.execute(sql_insert, new_user)
    
    # 5. Зафіксувати транзакцію
    # Без цього INSERT не буде збережено в базі
    conn.commit()
    print("Нового користувача успішно додано.")

    # 3. Виконати запит (SELECT)
    cursor.execute("SELECT id, username, email FROM users;")
    
    # 4. Отримати результат
    print("\nВсі користувачі в базі:")
    all_users = cursor.fetchall() # fetchall() - отримати всі рядки
    for user in all_users:
        print(f"ID: {user[0]}, Username: {user[1]}, Email: {user[2]}")

except (Exception, psycopg2.DatabaseError) as error:
    print(f"Помилка при роботі з PostgreSQL: {error}")

finally:
    # 6. Закрити курсор та з'єднання
    if cursor is not None:
        cursor.close()
    if conn is not None:
        conn.close()
    print("\nЗ'єднання з PostgreSQL закрито.")

```