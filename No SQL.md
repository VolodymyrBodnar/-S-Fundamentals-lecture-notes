# Чому потребне NoSQL?

## 1.1.  SQL та її межі

Протягом десятиліть світ розробки програмного забезпечення жив у парадигмі, де реляційні бази даних були незаперечним королем. Технології, що використовують мову SQL (Structured Query Language), стали фундаментальним стандартом для зберігання та управління даними. Вони пропонували надійність, порядок і передбачуваність. Вся інформація акуратно розкладалася по таблицях, які складалися з рядків та стовпців, подібно до добре організованої картотеки.

Ключовою перевагою цього підходу була жорстка, заздалегідь визначена схема. Перш ніж записати будь-які дані, розробник мав чітко описати структуру таблиці: назви стовпців та типи даних, які вони могли містити. Це забезпечувало високу якість та узгодженість даних. Але головною запорукою надійності були транзакції, що відповідали принципам **ACID** (Atomicity, Consistency, Isolation, Durability). Ця абревіатура гарантувала, що будь-яка операція, наприклад, банківський переказ, буде виконана повністю і коректно, або не виконана зовсім, захищаючи систему від часткових і помилкових змін. Такий підхід був і залишається ідеальним для корпоративних систем, фінансових установ та будь-яких додатків, де точність даних є абсолютним пріоритетом.

## 1.2. Нова епоха: виклики Вебу 2.0

На початку 2000-х років ландшафт інтернету почав кардинально змінюватися. На сцену вийшли такі гіганти, як Google, Facebook та Amazon. Вони зіткнулися з проблемами такого масштабу, для вирішення яких існуючі SQL-орієнтовані інструменти виявилися недостатньо гнучкими. Виклики нової епохи можна охарактеризувати трьома ключовими аспектами.

По-перше, це **об'єм даних**. Кількість інформації, що генерувалася користувачами, почала зростати експоненціально. Мова йшла вже не про тисячі чи навіть мільйони записів, а про мільярди щоденних подій: лайки, коментарі, фотографії, геолокаційні мітки, показники з мільйонів IoT-пристроїв. Традиційні бази даних, що покладалися на **вертикальне масштабування** — тобто збільшення потужності одного сервера шляхом додавання пам'яті чи кращих процесорів — швидко досягали своєї фізичної та фінансової межі.

По-друге, це **швидкість**. Глобальні додатки з мільйонами одночасних користувачів вимагали миттєвого відгуку. Соціальні мережі, онлайн-ігри та рекомендаційні системи повинні були зчитувати та записувати дані з мінімальною затримкою. У світі SQL це ставало проблемою, оскільки складні запити з об'єднаннями (`JOIN`) кількох таблиць, які є серцем реляційної моделі, починали працювати дуже повільно під високим навантаженням, стаючи "вузьким місцем" усієї системи.

По-третє, це **різноманітність даних**. Інформація перестала бути однорідною та легко структурованою. Профіль одного користувача міг містити десятки полів, тоді як інший мав лише ім'я та електронну адресу. Повідомлення в чатах, об'єкти у форматі JSON, що надходять від сторонніх API, мультимедійні файли — все це різноманіття було важко втиснути у жорсткі рамки заздалегідь визначеної схеми. Будь-яка спроба змінити структуру, наприклад, додати нове поле до профілю користувача, вимагала виконання складної та ризикованої операції `ALTER TABLE`, яка могла заблокувати роботу з величезною таблицею на тривалий час.

## 1.3. Рішення: Народження NoSQL

У відповідь на ці виклики почала формуватися нова філософія роботи з даними, яка отримала назву NoSQL, що сьогодні найчастіше розшифровують як "Not Only SQL" ("Не тільки SQL"). Це не одна конкретна технологія, а ціле сімейство різноманітних баз даних, кожна з яких пропонувала свій підхід до вирішення проблем нового цифрового світу.

Замість дорогого вертикального масштабування, NoSQL-системи запропонували **горизонтальне масштабування**, або шардинг. Ця концепція полягає у розподілі даних на безліч звичайних, відносно дешевих серверів. Коли системі стає недостатньо потужності, до неї просто додають нові сервери, що є значно дешевшим і практично безмежним у своєму потенціалі.

Проблему різноманітності даних вирішила **гнучка модель даних**. Більшість NoSQL баз не вимагають жорсткої схеми. Це означає, що в одній колекції можна зберігати документи з абсолютно різним набором полів, що ідеально підходить для еволюціонуючих додатків та неструктурованої інформації.

Нарешті, для забезпечення **високої доступності**, NoSQL бази даних були спроєктовані з урахуванням відмовостійкості. Дані в них автоматично копіюються, або **реплікуються**, на кілька серверів. Якщо один із серверів виходить з ладу через збій обладнання чи мережі, система миттєво переключається на його копію і продовжує працювати безперебійно, забезпечуючи доступність сервісу 24/7.

Таким чином, NoSQL з'явився не для того, щоб знищити чи замінити SQL, а щоб доповнити його, запропонувавши ефективні інструменти для нового покоління додатків, де гнучкість, швидкість і масштабованість стали важливішими за сувору структурованість та абсолютну узгодженість даних.

## Ключові аспекти та відмінності NoSQL баз даних

## Загальний опис

NoSQL бази даних розроблені для ефективної обробки великих обсягів даних та високого трафіку, що робить їх ідеальним рішенням для сучасних масштабних додатків, таких як Google або Telegram.

## Ключові технічні аспекти NoSQL

### Розподілене зберігання даних

На відміну від SQL баз даних, які традиційно зберігають всю інформацію на одному центральному комп'ютері, NoSQL системи розподіляють дані між багатьма, іноді тисячами, серверів. Це дозволяє їм обробляти потенційно нескінченні обсяги інформації за умови наявності достатньої кількості серверів.

### Горизонтальне масштабування (шардинг)

NoSQL бази даних створені для горизонтального масштабування. Це означає, що для збільшення обсягу сховища та пропускної здатності достатньо додати до системи нові машини. Вони автоматично обробляють шардинг — процес розподілу даних між кількома машинами, що значно спрощує масштабування порівняно з SQL базами даних.

### Гнучка структура даних

NoSQL бази даних не вимагають жорсткої табличної структури з попередньо визначеними стовпцями та типами даних. Вони дозволяють зберігати інформацію в різних форматах, наприклад, у вигляді об'єктів JSON, і навіть мати документи з абсолютно різними полями в межах однієї колекції.

### Відсутність зовнішніх ключів та об'єднань (joins)

Зазвичай, NoSQL бази даних не використовують зовнішні ключі, а отже, і не підтримують операції об'єднання (`JOIN`). Для отримання пов'язаних даних інформація часто зберігається у вкладеному, денормалізованому форматі (наприклад, пости з вбудованими коментарями). Це може призвести до дублювання даних, але значно збільшує швидкість їх отримання.

### Кінцева узгодженість (Eventual Consistency) та модель BASE

NoSQL бази даних зазвичай працюють за принципом "кінцевої узгодженості". Це означає, що дані не обов'язково стають узгодженими на всіх реплікованих серверах одразу після операції запису, але з часом вони гарантовано синхронізуються. Цей підхід є частиною моделі **BASE**:

- **Basically Available (В основному доступний):** База даних намагається завжди надавати відповідь на запити, навіть якщо дані можуть бути не найсвіжішими.
- **Soft State (М'який стан):** Стан даних є плинним і може змінюватися, що означає, що різні сервери можуть тимчасово показувати різні стани одних і тих же даних через асинхронну реплікацію.
- **Eventual Consistency (Кінцева узгодженість):** Дані з часом стануть узгодженими на всіх серверах, хоча точний час цього не гарантується.

### Реплікація

Для запобігання втраті даних та забезпечення високої доступності NoSQL бази даних підтримують реплікацію. Кожен сервер, що зберігає частину даних (шард), може мати кілька серверів-копій (slaves або secondaries), які реплікують усі вхідні дані. Якщо головний сервер виходить з ладу, один із резервних серверів автоматично займає його місце.

## Порівняння з SQL базами даних

**SQL бази даних** зберігають усі дані на одному комп'ютері та використовують структуровану мову запитів (SQL). Вони гарантують транзакції **ACID** (атомарність, узгодженість, ізольованість, довговічність), що означає, що дані завжди знаходяться в узгодженому стані, а операції виконуються повністю або не виконуються взагалі. Ця сильна узгодженість є надзвичайно важливою для таких додатків, як банківські системи.

**NoSQL бази даних**, натомість, розроблені для розподілених систем і надають пріоритет доступності та стійкості до розділення над негайною узгодженістю. Вони підходять для додатків, де прийнятна кінцева узгодженість, наприклад, для стрічок соціальних мереж.


#  Теорема CAP. Фундаментальний компроміс розподілених систем

## 2.1. Вступ до теореми

Коли ми говоримо про системи, що складаються з багатьох серверів (тобто, розподілені системи), ми неминуче стикаємося з фундаментальними обмеженнями. Наприкінці 1990-х років вчений Ерік Брюер сформулював концепцію, яка пізніше стала відома як **теорема CAP**. Вона стверджує, що будь-яка розподілена система для зберігання даних може одночасно задовольнити лише дві з трьох наступних гарантій: **Consistency** (Узгодженість), **Availability** (Доступність) та **Partition Tolerance** (Стійкість до розділення).

Ця теорема є ключовою для розуміння архітектурних відмінностей між SQL та NoSQL базами даних, оскільки вона змушує розробників робити свідомий вибір і йти на компроміс.

## 2.2. Розбираємо компоненти CAP

Щоб зрозуміти суть компромісу, розглянемо кожну з трьох гарантій окремо.

### Consistency (Узгодженість)

Узгодженість означає, що всі клієнти, які звертаються до бази даних, бачать однакові дані в один і той же момент часу. Якщо один клієнт виконує операцію запису, то будь-який наступний запит на читання від будь-якого іншого клієнта повинен повернути саме цей, найсвіжіший результат. Іншими словами, система поводиться так, ніби вона є єдиним, цілісним організмом, навіть якщо фізично складається з десятків серверів. Це найсуворіша форма узгодженості, яку часто називають лінійною або сильною.

### Availability (Доступність)

Доступність гарантує, що кожен запит до системи отримує відповідь, і ця відповідь не є повідомленням про помилку. Система вважається доступною, якщо вона здатна обробляти запити на читання та запис, навіть якщо деякі її частини працюють некоректно. Головна ідея полягає в тому, що система завжди "на зв'язку" і готова відповідати користувачам.

### Partition Tolerance (Стійкість до розділення)

Стійкість до розділення — це здатність системи продовжувати функціонувати, навіть якщо між її серверами (нодами) виникають проблеми зі зв'язком. Уявіть, що ваша база даних розподілена між дата-центрами в Європі та США, і трансатлантичний кабель пошкоджено. "Розділення" (partition) — це і є цей розрив зв'язку. Стійка до розділення система повинна продовжувати працювати в обох ізольованих частинах. У сучасних розподілених системах ця властивість не є опцією — це вимога, оскільки збої в мережі є неминучою реальністю.

## 2.3. Неминучий вибір: CP або AP

Оскільки стійкість до розділення (**P**) є обов'язковою умовою для будь-якої надійної розподіленої системи, теорема CAP на практиці зводиться до вибору між узгодженістю та доступністю.

- **Системи типу CP (Consistency / Partition Tolerance):** Коли відбувається розрив мережі, система обирає узгодженість. Щоб уникнути ситуації, коли різні частини системи повертають різні дані, та частина системи, що не може синхронізуватися з іншими, стає недоступною для запису або навіть для читання. Вона радше відмовить у запиті, ніж поверне застарілі дані. **Традиційні реляційні бази даних (SQL)**, коли їх намагаються зробити розподіленими, тяжіють саме до цієї моделі.
- **Системи типу AP (Availability / Partition Tolerance):** Коли відбувається розрив мережі, система обирає доступність. Кожен вузол продовжує відповідати на запити, навіть якщо не може зв'язатися з іншими. Це означає, що дані на різних вузлах можуть тимчасово розсинхронізуватися. Система залишається доступною, але ціною цього є тимчасова втрата сильної узгодженості. З часом, коли зв'язок відновиться, дані синхронізуються. Цей підхід відомий як **кінцева узгодженість (eventual consistency)** і є характерним для більшості **NoSQL баз даних**.

Отже, вибір між SQL та NoSQL — це часто вибір між гарантією отримання завжди правильних даних (CP) та гарантією отримання хоч якихось даних (AP).

#  Практичне порівняння та місце SQL у сучасному світі

## 3.1. Два світи, два підходи: PostgreSQL vs. MongoDB

Теоретичні концепції, такі як теорема CAP, найкраще розкриваються на практичних прикладах. Для цього порівняємо двох яскравих представників своїх світів: **PostgreSQL**, потужну об'єктно-реляційну СУБД, що є флагманом світу SQL, та **MongoDB**, одну з найпопулярніших документо-орієнтованих NoSQL баз даних.

### Модель даних

Основна відмінність лежить у способі організації даних. **PostgreSQL** використовує реляційну модель. Дані зберігаються у таблицях, що складаються з рядків та стовпців. Кожна таблиця має жорстку, заздалегідь визначену схему. Якщо ми зберігаємо інформацію про користувачів та їхні замовлення, ми створимо дві окремі таблиці (`users` та `orders`) і з'єднаємо їх за допомогою зовнішнього ключа. Це забезпечує цілісність даних та усуває їх дублювання.

**MongoDB**, натомість, використовує документо-орієнтовану модель. Дані зберігаються у форматі BSON (бінарний JSON) у вигляді документів. Документи групуються в колекції, які можна вважати аналогами таблиць. Однак, на відміну від таблиць, колекції не вимагають однакової структури для всіх документів. В одному з них можуть бути три поля, в іншому — десять. Інформацію, яка в SQL була б у різних таблицях, тут часто вкладають в один документ. Наприклад, документ користувача може містити масив його замовлень. Це спрощує читання пов'язаних даних, оскільки не потребує операції `JOIN`.


До речі, цей підхід, коли ми вкладаємо пов'язані дані безпосередньо в один документ (як замовлення в профіль користувача), є яскравим прикладом **денормалізації** даних. Якщо ви пам'ятаєте з попередньої лекції, у світі SQL ми прагнемо до нормалізації, щоб усунути надлишковість та дублювання даних. У NoSQL-системах, натомість, ми часто свідомо йдемо на денормалізацію. Ми робимо це заради продуктивності: щоб отримати всю необхідну інформацію про сутність за один запит до бази, уникаючи складних і повільних об'єднань. Це компроміс, де ми жертвуємо ефективністю зберігання заради швидкості читання.

Це також підводить нас до ще одного важливого розрізнення — між **транзакційними (OLTP)** та **аналітичними (OLAP)** системами.

Традиційні SQL-системи, як PostgreSQL, історично оптимізовані для **OLTP (Online Transaction Processing)**. Це робота з великою кількістю коротких, швидких операцій: додати замовлення, оновити профіль, перевірити баланс. Тут ключовою є швидкість та надійність кожної окремої транзакції, що гарантується ACID.

З іншого боку, коли нам потрібно аналізувати величезні обсяги історичних даних — наприклад, "показати середній чек покупки за останній рік по всіх регіонах" — ми говоримо про **OLAP (Online Analytical Processing)**. NoSQL-системи, завдяки своїй архітектурі, часто є джерелом цих великих даних (Big Data). Вони чудово справляються зі збором та зберіганням мільярдів подій. Однак для самої аналітики часто використовують спеціалізовані сховища даних (Data Warehouses), які, що цікаво, теж часто базуються на SQL, але на його особливому, колонковому різновиді, оптимізованому саме для таких складних запитів.

Отже, можна сказати, що класичний SQL ідеальний для надійних транзакцій, тоді як NoSQL чудово підходить для збору даних у великих масштабах, які потім можуть бути використані для аналітики.
### Масштабування та узгодженість

Як ми вже знаємо з теореми CAP, підходи до масштабування та узгодженості у цих систем кардинально різні. **PostgreSQL** традиційно орієнтований на вертикальне масштабування і гарантує сильну узгодженість даних завдяки механізму **ACID**. Кожна транзакція є атомарною, узгодженою, ізольованою та довговічною.

**MongoDB** спроєктований для горизонтального масштабування (шардингу) і дотримується моделі **BASE** (Basically Available, Soft state, Eventual consistency). Це означає, що система надає пріоритет доступності, а узгодженість даних між різними репліками досягається з часом.

|Критерій|PostgreSQL (SQL)|MongoDB (NoSQL)|
|---|---|---|
|**Модель даних**|Структурована (таблиці, рядки)|Гнучка (JSON-подібні документи)|
|**Схема**|Жорстка, визначена наперед|Динамічна, безсхемна|
|**Масштабування**|Переважно вертикальне|Горизонтальне (шардинг)|
|**Узгодженість**|Сильна (ACID)|Кінцева (BASE)|
|**Зв'язки**|`JOIN` між таблицями|Вкладені документи, посилання|
|**Основна перевага**|Надійність та цілісність даних|Гнучкість та масштабованість|

## 3.2. Чому SQL досі домінує і де він незамінний?

Попри стрімкий розвиток NoSQL, реляційні бази даних не втратили своєї актуальності і продовжують домінувати в багатьох сферах. Важливо розуміти, що NoSQL — це не заміна, а альтернатива, і існують задачі, де використання SQL є не просто бажаним, а критично необхідним.

Головна причина — це **гарантія цілісності даних**. Модель ACID, яку надає SQL, є золотим стандартом для систем, де помилка може коштувати реальних грошей або призвести до серйозних логічних збоїв. Уявіть собі банківську систему: операція переказу грошей з одного рахунку на інший повинна бути виконана повністю, або не виконана зовсім. Не може бути ситуації, коли гроші з одного рахунку списалися, а на інший не надійшли. Саме цю гарантію і надає SQL.

Другий фактор — це **зрілість технології та потужність запитів**. Мова SQL є стандартизованою, зрозумілою мільйонам розробників і надзвичайно потужною для виконання складних аналітичних запитів. Можливість об'єднувати дані з десятків таблиць, агрегувати їх та фільтрувати за складними умовами є унікальною перевагою реляційних баз.

**Сфери, де SQL має критичну перевагу:**

- **Фінансові системи:** Банкінг, біржові платформи, процесинг платежів, бухгалтерія.
- **Системи управління (ERP, CRM):** Де бізнес-процеси базуються на чітких і складних зв'язках між сутностями (клієнти, замовлення, товари, поставки).
- **Системи, що вимагають складної аналітики:** Будь-яка сфера, де потрібно аналізувати структуровані дані зі складними залежностями.

Отже, вибір технології завжди залежить від задачі. Для додатків, що вимагають максимальної надійності та цілісності даних, SQL залишається найкращим вибором.

# Підсумки та відповідь для співбесіди

## 4.1. Як відповісти на питання "У чому різниця між SQL та NoSQL?"

На будь-якій технічній співбесіді на позицію розробника це питання є одним із найпопулярніших. Воно перевіряє не тільки ваші знання, але й ваше розуміння, коли і яку технологію варто застосовувати. Важливо дати структуровану, впевнену та лаконічну відповідь, яка продемонструє глибину вашого розуміння.

Ось приклад такої відповіді, яку можна взяти за основу.

### **Приклад відповіді для співбесіди:**

"Основна відмінність між SQL та NoSQL базами даних лежить у трьох ключових аспектах: **моделі даних**, підході до **масштабування** та гарантіях **узгодженості**.

**SQL бази даних**, такі як PostgreSQL, використовують **структуровану** модель даних, де інформація зберігається в таблицях з рядками та стовпцями. Вони мають жорстку, заздалегідь визначену схему. Такі бази гарантують **сильну узгодженість** даних завдяки транзакціям **ACID** і традиційно **масштабуються вертикально**, тобто шляхом збільшення потужності одного сервера. Це робить їх ідеальним вибором для систем, де цілісність та надійність даних є абсолютним пріоритетом, наприклад, у фінансових чи банківських додатках.

**NoSQL бази даних**, як-от MongoDB, натомість, пропонують **гнучкі** моделі даних, наприклад, документо-орієнтовану, де дані зберігаються у JSON-подібних документах без жорсткої схеми. Вони були спроєктовані для **горизонтального масштабування**, тобто легкого розподілу навантаження на безліч серверів. Замість сильної узгодженості, вони зазвичай пропонують модель **кінцевої узгодженості** (BASE), надаючи пріоритет високій доступності та відмовостійкості системи. Це робить їх чудовим вибором для великих розподілених систем з неструктурованими даними, як-от соціальні мережі, IoT-платформи або системи аналітики в реальному часі.

Отже, вибір між ними — це завжди **архітектурний компроміс**, який залежить від конкретних вимог проєкту. Якщо потрібна максимальна надійність і структурованість — це SQL. Якщо потрібні гнучкість, швидкість і масштабованість для великих обсягів даних — це NoSQL."

Ця відповідь показує, що ви розумієте не тільки "що" це таке, але і "навіщо" та "коли" це використовувати, що є ознакою хорошого інженера.

# Архітектура «нескінченної стрічки»: як працює TikTok та Instagram Reels

Створення персоналізованої, швидкої та нескінченної стрічки контенту — це одне з найскладніших завдань у сучасній веброзробці. Це не просто запит до однієї бази даних; це злагоджена робота цілої екосистеми сервісів, де кожна технологія, включно з різними типами NoSQL баз, використовується для вирішення своєї специфічної задачі.

Давайте розберемо цей процес на ключові компоненти.
### 1. Зберігання контенту: Відео та їх метадані

Коли користувач завантажує відео, воно не зберігається безпосередньо в базі даних.

- **Самі відеофайли** завантажуються у **сховище об'єктів (Object Storage)**, таке як Amazon S3 або Google Cloud Storage. Це спеціалізовані сервіси для зберігання великих файлів, які забезпечують їх надійність та швидку доставку через мережі доставки контенту (CDN).
- **Метадані відео** (опис, хештеги, автор, тривалість, посилання на файл у S3) зберігаються в базі даних. Тут часто використовують документо-орієнтовані NoSQL бази (як **MongoDB** або **DynamoDB**), оскільки структура метаданих може бути гнучкою.

### 2. Збір даних про взаємодію користувача

Це найважливіший етап для роботи алгоритмів. Кожна ваша дія — це сигнал для системи.

- **Лайки, коментарі, репости, час перегляду, підписки** — всі ці події записуються. Через їх величезну кількість (мільярди подій на годину) тут потрібні бази даних, оптимізовані для надвисокого навантаження на запис.
- **Технології:** Часто використовуються ширококолонкові NoSQL бази даних, такі як **Apache Cassandra** або **ScyllaDB**. Вони дозволяють записувати дані з величезною швидкістю, розподіляючи їх по сотнях серверів.

#### Що таке ширококолонкові бази даних?

Уявіть собі таблицю, але з надздібностями. На відміну від реляційних баз, де кожен рядок повинен мати однакові стовпці, у ширококолонкових базах кожен рядок є незалежним. Він ідентифікується унікальним ключем (`row key`), але може мати довільну кількість стовпців. Більше того, ці стовпці можна додавати "на льоту" для будь-якого рядка, не змінюючи структуру всієї "таблиці" (яка тут називається сімейством стовпців, або `column family`).

Така архітектура ідеально підходить для зберігання часових рядів (time-series data), якими, по суті, і є події взаємодії користувачів. Наприклад, ключем рядка (`row key`) може бути `user_id`, а кожен стовпець — це окрема подія, де ім'я стовпця містить мітку часу та тип події (наприклад, `like_17-07-2025T19:15:00`), а значення — `video_id`. Це дозволяє надзвичайно ефективно записувати величезну кількість подій для кожного користувача і потім так само ефективно їх зчитувати.

### 3. Машинне навчання: Мозок системи

Це ядро, яке робить стрічку персоналізованою. Це не база даних, а набір складних **алгоритмів машинного навчання (ML)**.

- **Вхідні дані:** ML-моделі аналізують всю зібрану інформацію: ваш профіль (вік, стать, місцезнаходження), ваші минулі взаємодії (що ви лайкали, як довго дивилися певні відео) та метадані самого контенту.
- **Результат:** На основі цього аналізу алгоритм генерує для кожного користувача список ID відео, які, на його думку, будуть найцікавішими. Цей процес відбувається асинхронно, у фоновому режимі.

### 4. Генерація та зберігання стрічки: Швидкість понад усе

Коли користувач відкриває додаток, він очікує побачити контент миттєво. Чекати, поки ML-модель щось порахує, занадто довго. Тому стрічка для кожного користувача **генерується заздалегідь**.

- **Сервіс генерації стрічки** періодично бере результати роботи ML-моделі (список рекомендованих ID відео) і зберігає їх у надшвидкому сховищі.
- **Технології:** Тут ідеальним інструментом є **Redis**. Це in-memory база даних типу "ключ-значення". Для кожного `user_id` створюється ключ, а значенням є список `video_id`. Оскільки Redis зберігає дані в оперативній пам'яті, читання відбувається за мілісекунди.

### 5. Як все працює разом: Шлях запиту

Давайте підсумуємо, що відбувається, коли ви відкриваєте TikTok:

1. **Запит:** Ваш телефон надсилає запит на сервер: "Дай мені стрічку для `user_id=123`".
2. **Швидка відповідь:** Бекенд-сервіс не йде до складної бази даних. Він звертається до **Redis** і миттєво отримує заздалегідь підготовлений список ID відео для вас (наприклад, `[video_A, video_B, video_C]`).
3. **Збагачення даних:** Маючи список ID, сервіс робить ще один швидкий запит до бази метаданих (наприклад, **MongoDB**), щоб отримати повну інформацію про ці відео (URL, опис, автора).
4. **Відповідь клієнту:** Сервіс відправляє вашому телефону готову "пачку" з 5-10 відео.
5. **Аналітика та попереднє завантаження:** Поки ви дивитеся перше відео, телефон у фоновому режимі надсилає на сервер аналітику (скільки секунд ви дивитесь) і вже запитує наступну "пачку" відео, щоб скролінг був безшовним.

Ця архітектура, де кожен компонент виконує свою вузькоспеціалізовану задачу, є прикладом **поліглот персистенції** (polyglot persistence) — використання різних технологій зберігання даних для різних потреб в рамках однієї системи.


# Бонусний розділ: Які бази даних використовують для ШІ та великих мовних моделей (LLM)?

Коли ми говоримо про бази даних для ШІ, важливо розрізняти два основні етапи: **навчання моделі** та її **використання в додатках**.

### 1. Навчання моделі: Озера даних

Величезні мовні моделі, як GPT, навчаються на петабайтах тексту та коду з усього інтернету. Зберігати такі обсяги даних у традиційній базі даних неефективно. Тому для навчальних датасетів використовують:

- **Розподілені файлові системи (Distributed File Systems):** Такі як HDFS (Hadoop Distributed File System).
- **Сховища об'єктів (Object Storage):** Amazon S3, Google Cloud Storage.

Це, по суті, гігантські "озера даних" (Data Lakes), де інформація зберігається у вигляді файлів. Головне завдання тут — не швидкий пошук, а паралельна обробка величезних обсягів даних під час тривалого процесу навчання.

### 2. Використання моделі: Векторні бази даних

Це найцікавіше і найновіше. Коли LLM навчена, її потрібно "заземлити" на конкретні знання для вашого додатку (наприклад, для чат-бота, що відповідає на питання по вашій внутрішній документації). Цей процес називається **Retrieval-Augmented Generation (RAG)**.

**Як це працює?**

1. **Векторизація:** Текст (документи, статті, описи товарів) розбивається на шматки (чанки) і перетворюється на числові вектори (embeddings) за допомогою спеціальної моделі. Ці вектори представляють семантичне значення тексту. Тобто, тексти зі схожим змістом матимуть близькі за значенням вектори.
2. **Зберігання:** Ці вектори зберігаються у спеціалізованому типі баз даних — **векторній базі даних**.

**Векторні бази даних (Vector Databases)** — це NoSQL бази, оптимізовані для однієї задачі: надшвидкого пошуку найближчих (найбільш схожих) векторів серед мільйонів чи мільярдів інших. Коли користувач ставить питання, воно теж перетворюється на вектор, і база даних миттєво знаходить найбільш релевантні шматки тексту з вашої бази знань.

Потім ці знайдені шматки тексту передаються LLM разом із запитом користувача, і модель генерує відповідь, базуючись на наданому контексті.


### 3. Операційні дані

Звісно, додатки на основі ШІ також використовують і звичайні бази даних для повсякденних завдань:

- **PostgreSQL (SQL):** Для зберігання профілів користувачів, платіжної інформації, налаштувань.
- **MongoDB (NoSQL):** Для зберігання історії чатів, логів, гнучких структур даних.
- **Redis (In-memory):** Для кешування запитів, керування сесіями.

Таким чином, сучасний ШІ-додаток — це знову ж таки приклад **поліглот персистенції**, де векторні бази даних відіграють унікальну і критично важливу роль у "підключенні" LLM до реальних знань.
# Робота з MongoDB через CLI у нашому Docker-проєкті

Коли ваш додаток запущено через `docker-compose`, кожен сервіс (FastAPI, MongoDB, Redis) працює у своєму власному ізольованому середовищі — контейнері. Щоб працювати з базою даних напряму, нам потрібно підключитися до командного рядка (shell) всередині контейнера MongoDB.

## Крок 1: Знаходимо ім'я контейнера MongoDB

Спочатку нам потрібно дізнатися точне ім'я або ID нашого контейнера з MongoDB. Для цього відкрийте новий термінал (не закриваючи той, де працює `docker-compose`) і виконайте команду:

```
docker ps
```

Ви побачите список запущених контейнерів. Результат буде схожий на цей:

```
CONTAINER ID   IMAGE          COMMAND                  CREATED         STATUS         PORTS                               NAMES
...            mongo:latest   "docker-entrypoint.s…"   ...             Up ...         0.0.0.0:27017->27017/tcp             chat-app-mongo-1
...            redis:latest   "docker-entrypoint.s…"   ...             Up ...         0.0.0.0:6379->6379/tcp               chat-app-redis-1
...            ...            "uvicorn main:app --h…"  ...             Up ...         0.0.0.0:8000->8000/tcp             chat-app-api-1
```

Нас цікавить контейнер з ім'ям, що закінчується на `-mongo-1`. У нашому випадку це `chat-app-mongo-1`.

## Крок 2: Підключаємося до MongoDB Shell (mongosh)

Тепер, знаючи ім'я контейнера, ми можемо виконати команду, яка запустить інтерактивну оболонку `mongosh` всередині цього контейнера.

```
docker exec -it chat-app-mongo-1 mongosh
```

- `docker exec`: команда для виконання чогось всередині запущеного контейнера.
- `-it`: прапори, що роблять сесію інтерактивною (ми можемо вводити команди).
- `chat-app-mongo-1`: ім'я нашого контейнера.
- `mongosh`: команда для запуску сучасної оболонки MongoDB.

Після виконання цієї команди ваш термінал зміниться і ви побачите запрошення MongoDB, щось на зразок `test>`. Це означає, що ви успішно підключилися до бази даних.

## Крок 3: Базові команди в mongosh

Ось кілька основних команд для навігації та перегляду даних.

#### Показати всі бази даних

```
show dbs
```

Ви побачите список системних баз (`admin`, `local`, `config`) і, якщо ви вже надсилали повідомлення, нашу базу `chat_app`.

#### Переключитися на нашу базу даних

```
use chat_app
```

Термінал підтвердить переключення: `switched to db chat_app`.

#### Показати всі колекції (аналог таблиць)

```
show collections
```

Ви побачите `users` та `messages`, якщо вони вже були створені додатком.

#### Переглянути всі документи в колекції

Щоб побачити всі повідомлення:

```
db.messages.find()
```

Результат може бути не дуже читабельним. Щоб відформатувати його у вигляді красивого JSON, додайте `.pretty()`:

```
db.messages.find().pretty()
```

Аналогічно можна переглянути користувачів:

```
db.users.find().pretty()
```

## Крок 4: Приклади CRUD-операцій у Shell

Ви можете виконувати всі операції з даними прямо звідси.

#### Пошук (Read)

Знайти всі повідомлення від користувача "test":

```
db.messages.find({ username: "test" })
```

#### Вставка (Create)

Додати нове повідомлення від імені "адміністратора":

```
db.messages.insertOne({
  username: "admin",
  text: "Це тестове повідомлення з CLI",
  timestamp: new Date() // new Date() створює поточну дату і час
})
```

#### Оновлення (Update)

Оновити текст повідомлення, яке ми щойно створили:

```
db.messages.updateOne(
  { username: "admin" },
  { $set: { text: "Оновлений текст з командного рядка" } }
)
```

#### Видалення (Delete)

Видалити повідомлення адміністратора:

```
db.messages.deleteOne({ username: "admin" })
```

## Крок 5: Виконання агрегації

Ви можете виконувати складні агрегаційні запити, які ми створювали в FastAPI, прямо в оболонці. Наприклад, знайдемо найактивніших користувачів:

```
db.messages.aggregate([
  { $group: { _id: "$username", message_count: { $sum: 1 } } },
  { $sort: { message_count: -1 } },
  { $limit: 5 }
])
```

## Крок 6: Вихід з mongosh

Щоб вийти з оболонки MongoDB і повернутися до звичайного терміналу вашої системи, просто введіть:

```
exit
```

Або натисніть `Ctrl+D`.