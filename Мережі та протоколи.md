
### Як працює мережа та чому це важливо для розуміння сучасного інформаційного світу

Мережа — це сукупність різних пристроїв (комп'ютерів, серверів, смартфонів та іншого обладнання), які можуть обмінюватися інформацією між собою. Кожен пристрій у мережі називають вузлом, а передача інформації здійснюється за допомогою спеціальних повідомлень, які називаються пакетами.

Щоб зрозуміти, як саме працює мережа, уявіть собі просту аналогію з поштовою системою. Ви маєте лист, який хочете надіслати другу. Щоб лист дійшов, ви повинні чітко зазначити адресу отримувача, опустити лист у поштову скриньку, після чого лист проходить через кілька сортувальних центрів і поштових відділень, доки не буде доставлений адресату. У мережі відбувається щось дуже схоже: ваш комп'ютер створює пакет даних, додає до нього адресу отримувача та власну адресу, а потім передає пакет у мережу. Далі спеціальні пристрої, які називаються маршрутизаторами, допомагають цьому пакету рухатися правильним шляхом, передаючи його від одного вузла до іншого, поки він не дійде до призначення.

Чому ж настільки важливо розуміти, як працюють мережі? У сучасному світі майже всі наші щоденні дії пов’язані з використанням інтернету чи локальних мереж. Коли ви надсилаєте повідомлення у месенджері, шукаєте інформацію в інтернеті, або дивитеся фільм онлайн — у цей момент ваша інформація подорожує мережею, проходячи десятки і сотні вузлів, долаючи тисячі кілометрів кабелів та бездротових каналів зв'язку. Без розуміння принципів роботи мереж неможливо створювати сучасні вебдодатки, підтримувати IT-системи або ефективно працювати з базами даних та сервісами.

Крім того, знання мереж дозволяє вирішувати проблеми, які можуть виникати у процесі передачі даних: наприклад, втрату пакетів, повільну швидкість передачі інформації, перевантаження мережі чи безпекові загрози. Якщо розробник чи адміністратор мережі розуміє, як саме інформація рухається мережею, він може оптимізувати маршрути передачі даних, ефективно організовувати ресурси та швидко знаходити та усувати збої.

Таким чином, мережі — це невидимий фундамент сучасного інформаційного суспільства. Від того, наскільки добре ви розумієте, як вони працюють, залежить і ваше вміння ефективно створювати, обслуговувати та вдосконалювати інформаційні технології.

### Принципи роботи мережі з використанням багаторівневої архітектури моделі OSI

Модель OSI (Open Systems Interconnection) — це стандарт, який описує, як відбувається передача даних у мережі, і складається вона із семи рівнів. Ця модель дозволяє зрозуміти, як саме інформація долає різноманітні перешкоди, рухаючись від джерела до кінцевого отримувача.


Розглянемо детальніше цей процес. Коли ви надсилаєте повідомлення через інтернет, інформація проходить кожен рівень моделі OSI зверху вниз на вашому пристрої, потім передається мережею, а на пристрої отримувача рухається вже знизу вгору, щоб бути зрозумілою іншому пристрою.
![[Frame 771712.png]]

1. Прикладний рівень (Application Layer)
Це найвищий рівень, з яким безпосередньо взаємодіє користувач через програмне забезпечення, таке як веббраузери, поштові клієнти та месенджери. На цьому рівні формуються повідомлення у зрозумілих для людини форматах. Наприклад, коли ви вводите адресу сайту в браузер, цей процес відбувається саме на прикладному рівні. До ключових протоколів цього рівня належать HTTP (для передачі вебсторінок), FTP (для файлів), DNS, SNMP та Telnet. У моделі TCP/IP цей рівень також охоплює протоколи, з якими користувачі стикаються щодня, як-от SMTP для надсилання електронних листів.
2. Рівень представлення (Presentation Layer)
Основна функція цього рівня — перетворення даних у стандартний формат, який буде зрозумілим для різних пристроїв у мережі. Це забезпечує сумісність між системами, які можуть використовувати різні способи кодування інформації. Саме тут можуть відбуватися такі процеси, як шифрування даних для безпечної передачі та їх стиснення для зменшення обсягу. Прикладами протоколів, що працюють на цьому рівні, є SSL та TLS, які використовуються для шифрування.
3. Сеансовий рівень (Session Layer)
Цей рівень відповідає за організацію комунікаційних сеансів між двома пристроями. Він встановлює, підтримує та коректно завершує з'єднання. Це схоже на встановлення телефонного дзвінка перед початком розмови. Конкретним прикладом роботи сеансового рівня є встановлення з'єднання для відеодзвінка або під час онлайн-гри. Протоколи, що тут використовуються, — NetBIOS та PPTP.
4. Транспортний рівень (Transport Layer)
На цьому рівні суцільне повідомлення з вищих рівнів розбивається на менші частини, які називаються сегментами. До кожного сегмента додаються службові заголовки, які допомагають керувати передачею. Цей рівень забезпечує надійність доставки даних, контролюючи сегменти на предмет втрати чи пошкодження. Найвідомішими протоколами тут є TCP (Transmission Control Protocol) та UDP (User Datagram Protocol).
TCP забезпечує надійну доставку, перевіряючи цілісність та порядок отримання пакетів, і може повторно надсилати втрачені дані. Його використовують там, де важлива точність, наприклад, при завантаженні вебсторінок.
UDP працює швидше, але не гарантує доставку чи правильний порядок пакетів. Його застосовують для потокового відео, онлайн-ігор та відеодзвінків, де швидкість важливіша за ідеальну точність.
5. Мережевий рівень (Network Layer)
Тут сегменти даних перетворюються на пакети шляхом додавання до них IP-адрес відправника та отримувача. Головне завдання цього рівня — маршрутизація, тобто визначення оптимального шляху для руху пакетів через мережу від джерела до пункту призначення. Цю функцію виконуюють спеціальні пристрої — маршрутизатори. Ключовим протоколом є IP (Internet Protocol), а також використовуються ARP, ICMP та IPSec.
6. Канальний рівень (Data Link Layer)
На цьому рівні пакети інкапсулюються у фрейми (кадри). Тут до даних додаються фізичні адреси пристроїв — MAC-адреси, які є унікальними для кожного мережевого адаптера і використовуються для ідентифікації пристроїв у межах однієї локальної мережі (наприклад, вашого домашнього Wi-Fi). Канальний рівень також відповідає за виявлення та корекцію помилок, що могли виникнути під час передачі фреймів на фізичному рівні. Прикладами протоколів є PPP, ATM та Ethernet.
7. Фізичний рівень (Physical Layer)
Це найнижчий рівень моделі, який безпосередньо відповідає за передачу даних у вигляді бітів. Він перетворює цифрові дані на фізичні сигнали — електричні, світлові або радіохвилі — і передає їх через фізичне середовище, таке як мідні кабелі, оптоволокно або бездротові канали зв'язку. На цьому рівні визначаються такі фізичні параметри сигналу, як напруга, частота та форма імпульсів. Прикладами технологій та стандартів є Ethernet (в частині кабелів та сигналів), USB та Bluetooth.

### Основи моделі TCP/IP та Internet Protocol

Модель TCP/IP — це сучасний стандарт, за яким побудований інтернет та більшість сучасних комп'ютерних мереж. Назва «TCP/IP» походить від двох ключових протоколів цієї моделі — TCP (Transmission Control Protocol) та IP (Internet Protocol). Саме на цих протоколах базується комунікація в інтернеті, забезпечуючи надійний і стандартизований спосіб передачі даних між комп’ютерами.

Хоч модель TCP/IP значно простіша за OSI, вона чітко відображає реальні процеси, що відбуваються у мережах. Вона складається з чотирьох основних рівнів: прикладний, транспортний, мережевий і канальний. Усі ці рівні тісно пов'язані між собою та взаємодіють для успішної передачі інформації.

На прикладному рівні моделі TCP/IP знаходяться протоколи, з якими щоденно взаємодіють користувачі: HTTP (перегляд вебсторінок), SMTP (надсилання електронних листів), FTP (передача файлів). Саме тут формується повідомлення, яке буде передаватися мережею.

На транспортному рівні моделі TCP/IP працюють два найважливіші протоколи: TCP та UDP. Протокол TCP забезпечує надійну передачу інформації, контролюючи порядок отримання пакетів, перевіряючи їх цілісність та повторно надсилаючи загублені пакети. Протокол UDP, навпаки, передає інформацію швидше, але без гарантій доставки чи порядку отримання. TCP використовують там, де важлива точність (наприклад, завансовані вебзастосунки), а UDP — там, де важлива швидкість (стрімінг відео, відеодзвінки чи онлайн-ігри).
![[Frame 771710.png]]
Наступним рівнем є мережевий, на якому працює протокол IP. Саме тут інформація поділяється на окремі пакети, і кожен з них отримує унікальну IP-адресу відправника та отримувача. Кожен пакет має заголовок, у якому прописаний маршрут його руху мережею. IP-протокол забезпечує маршрутизацію — визначення оптимального шляху, яким пакети дійдуть від відправника до отримувача.

Структура IP-адреси складається з чотирьох чисел у форматі IPv4 (наприклад, `192.168.1.1`) або більш сучасного формату IPv6 (наприклад, `2001:0db8:85a3:0000:0000:8a2e:0370:7334`). IP-адреса дозволяє чітко ідентифікувати кожен пристрій в інтернеті. Для маршрутизації пакетів використовуються спеціальні пристрої — маршрутизатори, що направляють пакети за оптимальними маршрутами, забезпечуючи їх успішну доставку до кінцевого пункту.

Найнижчий рівень моделі TCP/IP об'єднує в собі фізичний та канальний рівні OSI. Він забезпечує передачу пакетів мережею, використовуючи фізичні засоби: кабелі, Wi-Fi, оптоволокно.

Розглянемо спрощений приклад роботи з IP-адресою в Python:

```python
import socket

hostname = 'google.com'
ip_address = socket.gethostbyname(hostname)

print(f"IP-адреса для {hostname}: {ip_address}")

```

Цей приклад показує, як легко отримати IP-адресу будь-якого ресурсу в інтернеті.

Таким чином, модель TCP/IP є базою, завдяки якій всі сучасні пристрої можуть ефективно та надійно обмінюватись інформацією, а протокол IP відповідає за те, що ваші повідомлення завжди доходять до адресата, незалежно від того, де він перебуває у світі. Це робить інтернет таким зручним і глобальним, як ми його знаємо сьогодні.

### Як влаштований та функціонує інтернет. HTTP-протокол

Інтернет — це глобальна мережа комп'ютерів, яка базується на моделі TCP/IP. Основний протокол, який лежить в основі сучасного вебу, — це HTTP (Hypertext Transfer Protocol). HTTP відповідає за передачу гіпертекстових документів (вебсторінок, файлів, зображень тощо) між клієнтом (наприклад, браузером) і сервером.

HTTP побудований за схемою «запит-відповідь». Клієнт формує і надсилає HTTP-запит, а сервер його отримує, обробляє та повертає відповідь. Саме завдяки цій простій схемі ми бачимо вебсторінки, користуємося сервісами та отримуємо інформацію з усього світу за частки секунди.

**Структура HTTP-запиту** містить кілька основних частин:

Спочатку йде метод запиту (наприклад, GET, POST), потім ресурс (URL), і, нарешті, версія HTTP-протоколу. Наприклад:

```
GET /index.html HTTP/1.1
Host: example.com
User-Agent: Mozilla/5.0
Accept: text/html
```

Після цього можуть бути заголовки, такі як `Host`, `User-Agent`, `Accept`, `Content-Type` та інші, що містять додаткову інформацію для сервера.

Коли сервер отримує запит, він повертає відповідь, яка має **три основні складові:**

- статус-код (наприклад, `200 OK`, `404 Not Found`, `500 Internal Server Error`);
- заголовки відповіді (наприклад, `Content-Type: text/html`, `Content-Length`);
- тіло відповіді (HTML-сторінку, JSON-дані тощо).

Ось приклад типової відповіді сервера:

```
HTTP/1.1 200 OK
Content-Type: text/html; charset=UTF-8
Content-Length: 1024

<html>
<body>
<h1>Привіт, це проста сторінка!</h1>
</body>
</html>
```

**Коди стану відповідей** допомагають зрозуміти, що відбулося з нашим запитом:

- `200 OK` — запит оброблено успішно.
- `404 Not Found` — сервер не знайшов ресурс.
- `500 Internal Server Error` — помилка на сервері.
- `301 Moved Permanently` — ресурс перенесено на нову адресу.

Знання цих основ HTTP дозволяє ефективно налагоджувати вебдодатки, розуміти принципи роботи браузерів, і навіть створювати власні сервіси та сервіси, які спілкуються один з одним через веб.

### HTTP-запити: методи та коди стану відповідей

Коли ви взаємодієте з інтернетом, наприклад відкриваєте сторінку чи надсилаєте форму, ваш браузер посилає HTTP-запити. Важливою частиною запиту є його метод, який вказує серверу, що саме клієнт хоче зробити з ресурсом.

Найчастіше використовуються такі методи:

**GET** – використовується для отримання даних від сервера, наприклад, коли ви відкриваєте вебсторінку чи файл.

**Приклад GET-запиту:**

```http
GET /index.html HTTP/1.1
Host: example.com
User-Agent: Mozilla/5.0
Accept: text/html
```

**POST** застосовують для надсилання даних (форми реєстрації, файли, JSON-об’єкти тощо) на сервер.

**Приклад POST-запиту:**

```http
POST /submit-form HTTP/1.1
Host: example.com
Content-Type: application/x-www-form-urlencoded
Content-Length: 27

username=student&password=1234
```

Крім цих двох, існують також методи PUT (оновлення ресурсу), DELETE (видалення ресурсу), PATCH (часткове оновлення), але GET і POST зустрічаються найчастіше.

Після отримання запиту сервер повертає відповідь, яка починається з **коду стану відповіді**— цифрового коду, що позначає результат запиту:

- `200 OK` означає, що запит оброблений успішно.
- `404 Not Found` — сервер не знайшов запитуваний ресурс.
- `403 Forbidden` означає, що доступ до ресурсу заборонений.
- `500 Internal Server Error` повідомляє про помилку на сервері.
- `301 Moved Permanently` вказує, що сторінка переміщена, і браузер повинен використовувати новий URL для подальших запитів.

**Приклад відповіді сервера з кодом 200:**

```http
HTTP/1.1 200 OK
Content-Type: text/html
Content-Length: 137

<html>
<body>
  <h1>Сторінка успішно завантажена!</h1>
</body>
</html>
```

Розуміння HTTP-запитів і відповідей є важливим для розробників, адже саме завдяки цим протоколам здійснюється обмін даними між браузером та сервером. Розуміючи їх, ви зможете легше аналізувати помилки, покращувати швидкодію та забезпечувати стабільну роботу вебдодатків.


### Рівень операційної системи: Головний диспетчер мережі

Уявіть операційну систему (ОС) як головного диспетчера на величезному логістичному складі. Програми (браузер, ігри, сервери) — це клієнти, які хочуть відправити або отримати посилки (дані), а мережева карта (NIC) — це ворота, через які посилки прибувають і відправляються. Програми ніколи не спілкуються з воротами напряму. Вони подають заявку диспетчеру (ОС), а він уже робить всю складну роботу.
Ось як виглядає цей процес покроково.

---

### Вхідний запит: Шлях пакета від мережевої карти до програми
Коли хтось у світі відправляє запит на ваш сервер (наприклад, заходить на ваш сайт).
**Крок 1: Прибуття на залізо**
1. Сигнал (електричний або оптичний) надходить на вашу мережеву карту (NIC).
2. Мережева карта перетворює цей сигнал на цифровий формат — послідовність бітів, що формує **фрейм** (кадр).
3. Карта перевіряє MAC-адресу призначення у фреймі. Якщо це її власна адреса, вона приймає фрейм. Якщо ні — ігнорує.    
4. Прийнятий фрейм копіюється у спеціальний буфер (маленьку ділянку пам'яті) на самій мережевій карті.


**Крок 2: Сигнал тривоги для ядра**
1. Щоб повідомити процесор про нові дані, мережева карта генерує **апаратне переривання (interrupt)**. Це ніби смикнути за мотузку дзвоника, що змушує процесор негайно зупинити поточні справи і звернути увагу на мережеву карту.
2. Спрацьовує спеціальна програма в ядрі ОС — **драйвер мережевої карти**. Він копіює дані з буфера мережевої карти в оперативну пам'ять (RAM). З цього моменту даними повністю керує ядро Linux.

**Крок 3: "Розпаковка" пакета в мережевому стеку ядра**
Ядро Linux починає процес "деінкапсуляції" — воно розбирає пакет, рухаючись знизу вгору по мережевій моделі:
- **Канальний рівень:** Ядро знімає заголовок фрейму (з MAC-адресами). Те, що лишилось всередині, — це IP-пакет.
- **Мережевий рівень:** Аналізується заголовок IP-пакета. Ядро перевіряє IP-адресу призначення. Якщо вона правильна, заголовок IP знімається. Те, що всередині, — це TCP-сегмент.
- **Транспортний рівень:** Ядро дивиться на заголовок TCP. Найважливіше тут — **порт призначення** (наприклад, порт 443 для HTTPS). Ядро перевіряє, чи якась програма на комп'ютері "слухає" цей порт.

**Крок 4: Магія сокетів та файлових дескрипторів**

1. **Створення "пункту прослуховування" (Сокет):** Коли ваш вебсервер (наприклад, Nginx) стартував, він попросив ядро: "Будь ласка, створи для мене **сокет** і прив'яжи його до порту 443. Я буду чекати на ньому вхідні з'єднання". Цей сокет перебуває у стані `LISTEN`. Сокет — це абстракція, кінцева точка зв'язку, яку ОС надає програмі.
2. **Черга з'єднань:** Коли ядро на кроці 3 побачило пакет для порту 443, воно знаходить цей "слухаючий" сокет, виконує TCP-рукостискання для встановлення з'єднання, і ставить готове, встановлене з'єднання у спеціальну чергу.
3. **Заявка від програми (`accept()`):** Тим часом вебсервер "висить" на системному виклику `accept()`. Цим він каже ядру: "Я готовий прийняти нове з'єднання. Як тільки щось буде в черзі, дай мені знати".
4. **Видача довідки (Файловий дескриптор):** Коли ядро бачить, що є і готове з'єднання в черзі, і програма, що його чекає, воно створює **нове, унікальне з'єднання** і повертає програмі його ідентифікатор. Цей ідентифікатор — це просто **ціле число**, наприклад, 14. Це і є **файловий дескриптор**.

**Файловий дескриптор** — це універсальний "квиток" в Linux, яка дозволяє програмі взаємодіяти з якимось ресурсом ядра (файлом на диску, мережевим з'єднанням, каналом даних). Програма тепер не думає про IP-адреси чи порти. Вона просто каже ядру: "Прочитай дані з дескриптора №14" (`read(14, ...)` ) або "Запиши ці дані у дескриптор №14" (`write(14, ...)`).

А ядро вже саме перетворює ці прості команди на складний процес пакування даних у TCP-сегменти, IP-пакети, Ethernet-фрейми і відправки їх через мережеву карту.

### Вихідний запит: Зворотний шлях

Коли ваш комп'ютер надсилає дані, відбувається зворотний процес "інкапсуляції":

1. Програма пише дані у свій файловий дескриптор (сокет).
2. Ядро додає заголовок TCP (з портами).
3. Далі додає заголовок IP (з IP-адресами).
4. Далі додає заголовок Ethernet (з MAC-адресами).
5. Готовий фрейм передається драйверу, а той — на мережеву карту, яка перетворює його на сигнали.

Таким чином, ОС виступає посередником, який надає програмам простий файловий інтерфейс (`read`/`write`) для складної мережевої взаємодії, ховаючи всю магію з пакетами, драйверами та перериваннями всередині ядра.

### Поширені практичні питання та відповіді

#### 1. Як маршрутизатори розуміють, куди скерувати пакет далі, і як вони знаходять конкретний комп'ютер?

Це дворівневий процес, який залучає **мережевий** та **канальний** рівні:

- **Глобальна навігація за IP-адресою (Мережевий рівень):** Кожен пакет даних, що відправляється в інтернет, має IP-адресу призначення. Маршрутизатори — це пристрої, які працюють на мережевому рівні та виступають у ролі "дорожніх знаків" в інтернет. Вони не знають всього шляху до кінцевого комп'ютера. Вони лише дивляться на IP-адресу призначення в пакеті та, згідно зі своїми внутрішніми таблицями маршрутизації, визначають, на який наступний маршрутизатор потрібно відправити пакет, щоб він став "ближче" до мети. Так, крок за кроком, від одного маршрутизатора до іншого, пакет подорожує мережею, поки не досягне кінцевої локальної мережі.
- **Локальна доставка за MAC-адресою (Канальний рівень):** Коли пакет прибуває до фінального маршрутизатора (наприклад, вашого домашнього роутера), IP-адреса свою роботу виконала. Тепер потрібно доставити пакет конкретному пристрою у вашій локальній мережі (ноутбуку, а не смартфону). Тут в гру вступає канальний рівень, який використовує **MAC-адреси** — унікальні фізичні адреси мережевих карт. Маршрутизатор визначає, якому пристрою в локальній мережі належить IP-адреса з пакета, і передає йому дані вже за його MAC-адресою.


Давайте розширимо аналогію "вулиця-квартира", щоб включити всі три компоненти: IP-адресу, MAC-адресу та порт.
Уявіть, що ви відправляєте кур'єром важливий пакет документів у великий офісний центр.
### 1. IP-адреса — це **адреса офісного центру (вулиця і номер будинку)**.
- Це глобальна адреса, яка працює на **мережевому рівні**.
- Вона потрібна кур'єру (маршрутизатору), щоб доставити пакет у правильний будинок (правильну локальну мережу, наприклад, вашу домашню чи офісну) з будь-якої точки світу2222. Без цієї адреси кур'єр просто не знатиме, в яке місто і на яку вулицю їхати.

### 2. MAC-адреса — це **номер офісу або ім'я компанії на дверях**.

- Це фізична адреса, що працює на**канальному рівні**.
- Коли кур'єр прибув за правильною IP-адресою до офісного центру, йому потрібно знайти конкретну компанію серед десятків інших. Він дивиться у свій бланк і знаходить назву "Roga & Kopyta Inc." — це і є MAC-адреса. Вона дозволяє доставити пакет **конкретному пристрою** (вашому ноутбуку, а не колеги) в межах однієї локальної мережі (офісного центру).
### 3. Порт — це **конкретний відділ або співробітник, якому призначений пакет**.
- Порт працює на **транспортному рівні**.
- Пакет доставлено в правильний офіс "Roga & Kopyta Inc.". Але кому його віддати? На пакеті є примітка: "Для бухгалтерії". Це і є **порт**. Ваш комп'ютер (офіс) може одночасно виконувати багато завдань: у вас відкритий браузер (відділ вебперегляду), працює месенджер (відділ комунікацій) і завантажується файл (відділ завантажень). Номер порту вказує операційній системі, якій саме програмі призначені ці дані.

|Компонент|Рівень моделі|Аналогія|Пояснення з конспекту|
|---|---|---|---|
|**IP-адреса**|Мережевий|Адреса будинку (вулиця та номер)|Глобальна адреса для маршрутизації пакетів через інтернет до правильної локальної мережі7777.|
|**MAC-адреса**|Канальний|Номер офісу або ім'я на дверях|Фізична адреса пристрою для доставки даних конкретному комп'ютеру в межах однієї локальної мережі8.|
|**Порт**|Транспортний|Конкретний співробітник або відділ в офісі|Номер, що вказує, якій саме програмі на комп'ютері призначені дані (браузеру, грі, поштовому клієнту)9999.|

Таким чином, для успішної доставки даних потрібна вся трійка: **IP-адреса**, щоб знайти правильну мережу, **MAC-адреса**, щоб знайти конкретний пристрій у цій мережі, і **порт**, щоб передати дані правильній програмі на цьому пристрої.

#### 2. Як передається великий файл (наприклад, PDF-книга) і звідки ми знаємо, що він передався повністю і без помилок?

За це відповідає **транспортний рівень**, а саме протокол **TCP (Transmission Control Protocol)**.

1. **Розбиття на частини:** Перш ніж відправити, протокол TCP розбиває великий файл на безліч маленьких пронумерованих частин — **сегментів**.
2. **Контроль і надійність:** TCP — це надійний протокол. Це означає, що після відправки кожного сегмента він чекає на підтвердження від отримувача.
3. **Перевірка цілісності та повторна відправка:** Отримувач, збираючи сегменти, перевіряє, чи всі вони прийшли, чи не пошкоджені вони і чи правильний їхній порядок. Якщо якийсь сегмент загубився в дорозі або прийшов пошкодженим, отримувач не надсилає підтвердження. Відправник, не отримавши підтвердження за певний час, розуміє, що щось пішло не так, і**надсилає цей сегмент повторно**.
4. **Збірка файлу:** Процес триває, доки отримувач не збере всі сегменти та успішно не складе з них початковий файл. Саме завдяки цьому механізму контролю забезпечується точність і цілісність передачі даних, тому TCP використовують там, де важлива кожна частинка інформації, наприклад, при завантаженні файлів чи перегляді сайтів.

#### 3. Чому онлайн-відео іноді "підвисає" або втрачає якість, але рідко зупиняється повністю, на відміну від завантаження файлу?

Це пов'язано з вибором протоколу на транспортному рівні. Для потокового відео, відеодзвінків або онлайн-ігор часто використовується протокол **UDP**, а не TCP. Головна відмінність UDP в тому, що він **швидкий, але ненадійний**. Він просто надсилає дані, не чекаючи на підтвердження доставки і не перевіряючи порядок. Якщо кілька пакетів з відео загубляться, програвач, швидше за все, просто пропустить їх (що виглядає як короткий збій чи погіршення якості) і продовжить показувати наступні кадри. Для відео це прийнятно, бо швидкість важливіша за ідеальну точність кожного кадру. TCP б, навпаки, зупинив відтворення і вимагав повторної відправки втрачених пакетів, що викликало б довгі паузи.

#### 4. Що відбувається "за лаштунками", коли я вводжу в браузер `google.com`, а не його IP-адресу (наприклад, `142.250.203.110`)?

Коли ви вводите `google.com`, ваш комп'ютер насправді не знає, де це. Тому він спершу звертається до спеціального сервісу під назвою **DNS (Domain Name System)**.

- DNS — це протокол прикладного рівня, який працює як "телефонна книга інтернету".
- Ваш браузер надсилає запит до DNS-сервера: "Яка IP-адреса відповідає доменному імені `google.com`?".
- DNS-сервер шукає цю інформацію у своїй базі та повертає відповідну IP-адресу.
- І тільки після цього ваш браузер формує HTTP-запит і відправляє його на отриману IP-адресу.

#### 5. Навіщо потрібні HTTP-методи, як-от GET та POST? Чому не можна все робити одним методом?
HTTP-методи вказують серверу, яку дію клієнт (ваш браузер) хоче виконати з ресурсом. Розділення на методи робить комунікацію між клієнтом і сервером чіткою та безпечною.
- **GET:** Використовується для простого отримання даних. Коли ви відкриваєте сторінку, браузер надсилає GET-запит. Ці запити можна кешувати та додавати в закладки, вони не повинні змінювати нічого на сервері.
- **POST:** Використовується для надсилання даних на сервер з метою створення або оновлення ресурсу. Наприклад, коли ви заповнюєте форму реєстрації, коментуєте допис або завантажуєте файл, дані надсилаються у тілі POST-запиту. Такі запити не кешуються і при оновленні сторінки браузер спитає дозвіл на повторну відправку форми, щоб уникнути дублювання дій.

Використання різних методів дозволяє вебдодаткам правильно та безпечно обробляти різні наміри користувача.

#### 6. Cкільки одночасно підключень може тримати один пристрій

##### 1. Теоретична межа (Майже нескінченна)

Існує поширена помилка, що оскільки є 65 535 портів, то й максимальна кількість з'єднань — 65 535. Це невірно.
Сервер слухає на **одному** порту (наприклад, вебсервер на порту 443 для HTTPS). Але кожне унікальне з'єднання ідентифікується не лише портом сервера, а комбінацією з чотирьох елементів (для IPv4):

1. IP-адреса клієнта
2. Порт клієнта (випадковий, >1024)
3. IP-адреса сервера
4. Порт сервера (зазвичай один і той самий)

Оскільки у світі мільярди IP-адрес, і кожен клієнт має тисячі доступних портів для вихідних з'єднань, теоретична кількість одночасних підключень до одного порту одного сервера обчислюється квадрильйонами.
**Висновок:** Теоретично, протокол TCP/IP не є обмежуючим фактором.

## Філософія Linux: "Все є файл"

Щоб зрозуміти ліміти в Linux, потрібно пам'ятати головний принцип цієї системи: майже все, з чим вона працює, представлено у вигляді файлу. Це стосується і мережевих з'єднань. Коли ваш серверний додаток (наприклад, вебсервер) приймає нове підключення, ядро Linux створює **мережевий сокет** і передає програмі **файловий дескриптор** — унікальний номер, що посилається на цей сокет.
Отже, **ліміт на кількість одночасних з'єднань у Linux прямо пов'язаний з лімітом на кількість одночасно відкритих файлових дескрипторів**.

## Три рівні обмежень файлових дескрипторів

У Linux існує трирівнева ієрархія лімітів, і для досягнення високої продуктивності потрібно налаштувати кожен з них.
### Загальносистемний ліміт (Стеля)

Це максимальна кількість файлових дескрипторів, які може обробляти ядро операційної системи в цілому, для всіх процесів разом узятих.

**Перевірка:**

```bash
cat /proc/sys/fs/file-max
```

Зазвичай це значення дуже велике (кілька мільйонів) і рідко є вузьким місцем.

**Зміна (перманентно):**

Відредагуйте файл `/etc/sysctl.conf`:

```
fs.file-max = 2000000
```

Застосуйте зміни:

```bash
sudo sysctl -p
```

### Ліміт для користувача або процесу

Це максимальна кількість файлів, яку може відкрити **один процес** або **один користувач**. Має два типи: `soft limit` (поточний) і `hard limit` (максимальний дозволений).

**Перевірка:**

```bash
ulimit -n   # soft
ulimit -Hn  # hard
```

**Зміна через `limits.conf`:**

```conf
* soft nofile 65536
* hard nofile 131072
```

Застосовується після перезапуску сесії.

**Зміна для systemd-сервісу:**

```bash
sudo systemctl edit nginx.service
```

Додайте:

```ini
[Service]
LimitNOFILE=65536
```

Потім:

```bash
sudo systemctl daemon-reexec
sudo systemctl restart nginx
```

### Ліміт на рівні самого додатку

Наприклад, у Nginx є директива `worker_connections`, яка не може перевищувати `LimitNOFILE`.

## Реальні обмеження: апаратні ресурси

Навіть при коректних налаштуваннях, кількість з'єднань обмежують:

**RAM:** Кожен сокет споживає памʼять. При її нестачі активується swap або `OOM Killer`.

**CPU:** Використовується для обробки логіки, запитів, SSL і т.п.

---

## Висновок

Щоб сервер Linux обробляв десятки або сотні тисяч з'єднань:

- Підніміть ліміти через `sysctl` та `systemd`.
- Налаштуйте серверний додаток під нові ліміти.
- Переконайтесь, що сервер має достатньо оперативної памʼяті та процесорних ресурсів.

### Реалізація простого та вдосконаленого HTTP-сервера на Python

Після розуміння принципів HTTP-протоколу перейдемо до практичної реалізації простого HTTP-сервера на Python.

Почнемо з найпростішого способу створити сервер, використовуючи вбудовані можливості Python.

**Приклад простого HTTP-сервера на Python:**

```python
from http.server import HTTPServer, SimpleHTTPRequestHandler

server_address = ('', 8000)  # Сервер запускається на локальному порту 8000
httpd = HTTPServer(server_address=('localhost', 8000), RequestHandlerClass=SimpleHTTPRequestHandler)

print("Сервер запущено на порту 8000...")
httpd.serve_forever()
```

Цей сервер автоматично обробляє GET-запити та повертає статичні файли, що знаходяться в директорії, звідки він запущений. Щоб перевірити його роботу, достатньо перейти за адресою `http://localhost:8000`.
Хоч цей сервер і простий у використанні, він має обмежену функціональність. Для більш серйозних задач, таких як створення API, потрібні гнучкіші інструменти, наприклад, бібліотека Flask.
Flask дозволяє створювати сервери, здатні обробляти різні методи HTTP, такі як GET, POST, та інші, легко працювати з параметрами URL та HTTP-заголовками.
Ось як виглядатиме простий HTTP-сервер на Flask:

```python
from flask import Flask, request, jsonify

app = Flask(__name__)

@app.route('/')
def home():
    return 'Привіт, це головна сторінка!'

@app.route('/user/<username>')
def user_profile(username):
    return f'Профіль користувача: {username}'

@app.route('/submit', methods=['POST'])
def submit_data():
    data = request.json
    return {'status': 'received', 'data': data}, 201

if __name__ == '__main__':
    app.run(debug=True, host='127.0.0.1', port=5000)
```

У цьому прикладі Flask автоматично розпізнає URL-адреси (`/`, `/user/<username>`) і методи запитів (наприклад, POST). Це дозволяє легко обробляти різні сценарії роботи вашого сервера та робити вебдодаток більш інтерактивним і функціональним.
Таким чином, знаючи ці два підходи — від простого стандартного HTTP-сервера до більш просунутої реалізації на Flask — ви можете швидко створювати як прості сайти для тестування, так і складніші вебзастосунки. Це розуміння суттєво полегшує розробку будь-яких сучасних вебсервісів.
Ось як легко створити простий HTTP-сервер на Python, який завантажує та повертає файл `index.html`:
Спочатку створіть файл `index.html`, наприклад такий:

```html
<!DOCTYPE html>
<html lang="uk">
<head>
    <meta charset="UTF-8">
    <title>Проста сторінка</title>
</head>
<body>
    <h1>Вітаємо на простому HTTP-сервері!</h1>
    <p>Це приклад статичної сторінки.</p>
</body>
</html>
```

Тепер створіть файл Python, наприклад `simple_server.py`:
```python
from http.server import HTTPServer, SimpleHTTPRequestHandler

class MyHandler(SimpleHTTPRequestHandler):
    def do_GET(self):
        if self.path == '/':
            self.path = '/index.html'
        return super().do_GET()

server_address = ('localhost', 8000)
httpd = HTTPServer(server_address, MyHandler)

print("Сервер запущено на http://localhost:8000")
httpd.serve_forever()
```

Цей код запускає простий HTTP-сервер, який за замовчуванням завантажує файл `index.html`. Запустіть сервер командою:
```shell
python simple_server.py
```

Після цього відкрийте браузер за адресою:  
`http://localhost:8000`
і побачите сторінку з вашого HTML-файла.