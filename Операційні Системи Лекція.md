### **Вступ**

Операційна система (ОС) – це базове програмне забезпечення, яке керує всіма ресурсами комп’ютера та забезпечує зручну взаємодію між користувачем і пристроєм. Вона діє як посередник між апаратною частиною та програмами, які виконуються на комп’ютері. Без ОС всі дії довелося б виконувати вручну через машинні коди або команди, що робило б роботу з комп’ютером надзвичайно складною.

Основне завдання ОС – організовувати роботу всіх пристроїв, що входять до складу комп’ютера, розподіляти ресурси між програмами, забезпечувати зберігання та доступ до файлів, а також керувати виконанням програм. Наприклад, коли користувач відкриває текстовий документ, операційна система зчитує файл з диска, завантажує його в оперативну пам’ять, запускає текстовий редактор і забезпечує виведення даних на екран. У той самий момент ОС слідкує за тим, щоб інші програми також мали доступ до необхідних ресурсів і не заважали одна одній у роботі.

Операційна система виконує дві ключові функції: **абстракцію** та **арбітраж**. **Абстракція** дозволяє приховати складність роботи апаратного забезпечення, надаючи програмам простіший та уніфікований інтерфейс. Наприклад, незалежно від виробника жорсткого диска або процесора, ОС надає стандартні API для роботи з файлами, пам’яттю та пристроями, що спрощує розробку програмного забезпечення.

**Арбітраж** – це механізм керування ресурсами між процесами, забезпечуючи справедливий доступ та ізоляцію. ОС вирішує, який процес отримає процесорний час, як розподіляється пам’ять і які програми можуть отримати доступ до пристроїв, таких як диск чи мережа. Це дозволяє системі ефективно працювати у багатозадачному середовищі, запобігаючи конфліктам і забезпечуючи безпеку.

Керування процесами є однією з найважливіших функцій ОС. Кожна програма, яка виконується на комп’ютері, є процесом, що споживає ресурси: процесорний час, оперативну пам’ять, доступ до файлів та периферійних пристроїв. Операційна система планує виконання всіх активних процесів, забезпечує їхню ізоляцію та дозволяє їм взаємодіяти між собою. Якщо одна програма зависає або використовує забагато ресурсів, ОС може її примусово зупинити або обмежити.

Ще однією важливою функцією є керування пам’яттю. Оперативна пам’ять є обмеженим ресурсом, і ОС розподіляє її між усіма активними процесами, слідкуючи за тим, щоб вони не втручалися в області пам’яті один одного. Для оптимізації роботи комп’ютера використовуються такі механізми, як кешування та віртуальна пам’ять, які дозволяють програмам працювати, навіть якщо оперативної пам’яті не вистачає.

Файлова система є ще одним ключовим компонентом ОС. Вона організовує зберігання даних на дисках, забезпечуючи доступ до файлів та каталогів. Без операційної системи користувач не зміг би зручно працювати з файлами, оскільки довелося б вручну вказувати фізичні адреси секторів на диску. Завдяки файловим системам, таким як NTFS, ext4 чи FAT32, дані зберігаються у впорядкованій структурі, що дозволяє швидко їх знайти, перемістити або видалити. ОС також забезпечує контроль доступу до файлів, визначаючи, хто і які операції може виконувати.

Операційна система також керує всіма підключеними до комп’ютера пристроями. Клавіатура, миша, принтер, відеокарта, мережевий адаптер – усі ці пристрої працюють завдяки драйверам, які взаємодіють з ОС. Драйвери є спеціальними програмами, що дозволяють ОС розпізнавати та використовувати апаратне забезпечення. Якщо користувач підключає новий принтер або зовнішній диск, ОС автоматично встановлює або пропонує встановити драйвери, щоб пристрій міг працювати.

Безпека є ще однією важливою складовою роботи ОС. Вона забезпечує контроль доступу до системних ресурсів, захищає файли від несанкціонованого доступу, керує правами користувачів і забезпечує ізоляцію процесів. В сучасних ОС реалізовані механізми аутентифікації та шифрування, що дозволяє зберігати конфіденційні дані без ризику їх втрати або крадіжки.

Якщо поглянути на роботу ОС з практичної точки зору, можна поставити кілька запитань, які допоможуть краще зрозуміти її значення. Чи могли б ми керувати комп’ютером без ОС? Чи всі пристрої використовують одну й ту саму операційну систему? Чим відрізняється ОС смартфона від ОС сервера? Відповіді на ці питання допомагають зрозуміти, що без операційних систем сучасна цифрова техніка просто не могла б функціонувати.

### **Історія розвитку операційних систем**

Операційні системи пройшли довгий шлях від простих програм керування апаратним забезпеченням до складних багатозадачних систем. Розвиток ОС можна розділити на кілька етапів, кожен з яких відображає зміну обчислювальних технологій і підходів до програмування.

---

### **1. Перші покоління (1950-ті – початок 1960-х)**

У 1950-х роках перші комп’ютери, такі як **ENIAC** або **IBM 701**, не мали операційних систем у сучасному розумінні. Програми записувалися вручну на перфокартах і виконувалися безпосередньої взаємодії з користувачем.

Згодом з’явилися **пакетні системи (Batch Processing Systems)**, де група завдань оброблялася без втручання людини. Наприклад, **GM-NAA I/O** (1956) – одна з перших примітивних ОС, створена для комп’ютерів IBM 704.

---

### **2. Епоха мейнфреймів та перших ОС (1960-ті – 1970-ті)**

У 1960-х з’явилися перші повноцінні ОС. **IBM OS/360** (1964) стала революційною системою, оскільки могла працювати на різних комп’ютерах однієї серії.

Значним проривом став **Multics (1969)** – перша спроба створити модульну багатокористувацьку систему. Хоча Multics не стала популярною, її ідеї стали основою для створення **Unix**.

---

### **3. Unix та епоха мінікомп’ютерів (1970-ті – 1980-ті)**

**Unix (1969-1971)** – одна з найвпливовіших ОС, розроблена в Bell Labs (Кен Томпсон і Денніс Рітчі). Вона була багатозадачною, багатокористувацькою і мала ієрархічну файлову систему. Головні принципи Unix: **"все є файлом"**, модульність, прості інструменти.

У 1980-х Unix почав поширюватися завдяки версії **BSD (Berkeley Software Distribution)**, яка стала основою для macOS та багатьох сучасних Unix-систем.

Також у цей період з’явилися перші персональні комп’ютери. **CP/M (1974)** була популярною ОС для 8-бітних комп’ютерів.

---

### **4. Поява Windows та графічних інтерфейсів (1980-ті – 1990-ті)**

У 1980-х почалася ера графічних інтерфейсів. **Xerox Alto (1973)** стала першою системою з GUI, а **Apple Lisa (1983)** та **Macintosh (1984)** зробили цю концепцію популярною.

Microsoft спочатку працювала над **MS-DOS (1981)**, а потім випустила **Windows 1.0 (1985)** – графічну оболонку для DOS. Windows почала набирати популярність у 1990-х із версіями **Windows 3.1 (1992)** та **Windows 95 (1995)**, яка мала сучасний інтерфейс, підтримку "Plug and Play" і файлову систему FAT32.

---

### **5. Відкрите програмне забезпечення та Linux (1990-ті – 2000-ні)**

У 1991 році **Лінус Торвальдс** створив **ядро Linux**, що стало основою для безкоштовної та відкритої альтернативи Unix. Дистрибутиви, такі як **Debian (1993)**, **Red Hat (1994)** та **Ubuntu (2004)**, зробили Linux популярним серед серверів і ентузіастів.

У цей час також з’явився **Windows NT (1993)** – нова архітектура Windows, яка стала основою для всіх наступних версій, включно з Windows XP, Windows 7 та Windows 10.

---

### **6. Сучасні ОС (2010-ті – 2020-ті)**

Операційні системи стали більш універсальними та безпечними. **Windows 10 (2015)** отримала регулярні оновлення, а **Windows 11 (2021)** принесла підтримку нових процесорів і TPM 2.0.

Linux продовжує домінувати у сфері серверів, а також став основою для мобільних ОС – **Android** базується на ядрі Linux.

macOS перейшла на власні ARM-чіпи (M1, M2), що підвищило продуктивність і автономність MacBook.

---

### **Архітектура операційної системи: ядро та компоненти**

Операційна система складається з кількох рівнів, кожен з яких виконує свою роль у забезпеченні стабільної та ефективної роботи комп’ютера. В основі будь-якої ОС знаходиться **ядро**, яке безпосередньо взаємодіє з апаратним забезпеченням і виконує найважливіші функції управління ресурсами.

Операційна система складається з **кількох шарів (або рівнів абстракції)**, кожен із яких виконує певні функції та взаємодіє з нижчим і вищим рівнем. Найнижчий рівень – це **апаратне забезпечення**, яке включає процесор, пам’ять, пристрої введення-виведення та інші компоненти. Над ним розташоване **ядро ОС**, яке керує ресурсами та забезпечує механізми взаємодії між програмами та апаратурою.

Наступний шар – **системні бібліотеки та сервіси**, які надають програмам стандартизовані інтерфейси для роботи з файловою системою, мережею, пам’яттю та іншими ресурсами. Найвищий рівень – **користувацькі програми та оболонка (CLI або GUI)**, які безпосередньо взаємодіють із користувачем. Така багаторівнева структура дозволяє ОС бути модульною, захищеною та гнучкою, забезпечуючи ізоляцію процесів і можливість одночасного виконання різних завдань.
![[Different-layers-of-operating-system.png]]

Ядро можна уявити як "серце" операційної системи, що забезпечує зв’язок між програмами та апаратними компонентами. Коли користувач відкриває програму, ядро виділяє їй ресурси, завантажує необхідні дані в оперативну пам’ять, визначає, коли саме вона отримає доступ до процесора, та гарантує, що вона не конфліктує з іншими програмами.

![[Pasted image 20250211165421.png]]

Існує кілька підходів до організації ядра. **Монолітне ядро**, яке використовується в Linux, містить всі основні функції операційної системи в одному великому блоці коду. Це дозволяє забезпечити швидку взаємодію між компонентами, оскільки всі вони працюють у єдиному середовищі, але водночас така структура ускладнює внесення змін та оновлення. **Мікроядро**, навпаки, реалізує мінімальний набір функцій, передаючи більшість завдань у вигляді окремих процесів, що працюють у користувацькому просторі. Це робить систему більш гнучкою та надійною, оскільки збій одного модуля не впливає на роботу всього ядра, проте взаємодія між модулями відбувається повільніше. **Гібридне ядро**, як у Windows або macOS, поєднує риси обох підходів, намагаючись знайти баланс між продуктивністю та гнучкістю.

Ядро ОС взаємодіє з іншими компонентами, які формують загальну архітектуру системи. Основним інтерфейсом для взаємодії програм із ядром є **системні виклики (syscalls)**. Коли програма хоче, наприклад, відкрити файл або отримати доступ до мережі, вона не може зробити це напряму, а звертається до ядра через системні виклики. ОС контролює ці запити, перевіряє права доступу, виконує необхідні операції та повертає результат програмі.

Однією з ключових складових операційної системи є **підсистема управління процесами**. Вона відповідає за створення, виконання, планування та завершення процесів. Кожен процес – це окрема програма або її частина, що виконується на комп’ютері. Ядро визначає, коли і як процес отримає доступ до процесора, щоб забезпечити рівномірний розподіл обчислювальних потужностей. Для цього використовуються алгоритми планування, які дозволяють ефективно керувати багатозадачністю.
![[Pasted image 20250211165620.png]]
Ще одним важливим компонентом є **система управління пам’яттю**, яка забезпечує оптимальне використання оперативної пам’яті комп’ютера. Коли програма запускається, вона отримує певний обсяг пам’яті, необхідний для її роботи. ОС стежить за тим, щоб процеси не використовували пам’ять, яка їм не належить, і щоб ресурси виділялися ефективно. Якщо оперативної пам’яті не вистачає, система може використовувати віртуальну пам’ять, зберігаючи частину даних на жорсткому диску та завантажуючи їх у RAM за потреби.

Керування файлами та файловою системою також є важливою частиною архітектури ОС. Файлова система дозволяє користувачам організовувати, зберігати та отримувати доступ до даних. Вона відповідає за розміщення файлів на носіях, їхню ідентифікацію та контроль доступу. Операційна система підтримує різні файлові системи, такі як NTFS у Windows, ext4 у Linux або APFS у macOS, кожна з яких має свої особливості та оптимізована для певних сценаріїв використання.

Ще один важливий компонент – **драйвери пристроїв**, які дозволяють операційній системі працювати з апаратним забезпеченням. Драйвери – це спеціальні програми, що перекладають команди ОС у формат, зрозумілий для конкретного пристрою. Наприклад, коли користувач друкує документ, драйвер принтера перетворює завдання друку у зрозумілий принтеру набір команд. Без драйверів операційна система не могла б розпізнати нові пристрої та ефективно взаємодіяти з ними.

Останнім важливим елементом архітектури є **інтерфейс користувача**. ОС надає два основні способи взаємодії: графічний інтерфейс (GUI) та командний рядок (CLI). Графічний інтерфейс спрощує роботу, надаючи візуальні елементи, такі як вікна, кнопки та меню, тоді як командний рядок дозволяє виконувати дії швидше та автоматизувати процеси за допомогою команд. У серверних системах, таких як Linux, CLI використовується набагато частіше, оскільки він забезпечує гнучкість та ефективність.

Архітектура операційної системи – це складна багаторівнева структура, що поєднує в собі ядро, системні сервіси, файлову систему, механізми керування пам’яттю та процесами, драйвери пристроїв і користувацький інтерфейс. Взаємодія цих елементів дозволяє ОС ефективно виконувати свої функції та забезпечувати стабільну роботу комп’ютера.

### **Ядро операційної системи: архітектура та роль у GNU/Linux**

Ядро є центральною частиною будь-якої операційної системи. Воно відповідає за управління ресурсами комп’ютера, координацію роботи всіх апаратних та програмних компонентів, а також забезпечення безпечного та ефективного виконання процесів. У випадку GNU/Linux ядро має **монолітну архітектуру**, але водночас підтримує можливість завантаження модулів, що додає йому гнучкості.

### **Монолітне ядро Linux: особливості та переваги**

На відміну від мікроядерних систем, де основні функції винесені в окремі модулі, ядро Linux є **монолітним**, тобто воно містить більшість критичних функцій у своїй основній частині. Усі компоненти, такі як драйвери пристроїв, файлові системи та механізми мережевої взаємодії, працюють у привілейованому режимі, що дозволяє виконувати операції максимально швидко та ефективно.

Основна перевага монолітного ядра полягає в тому, що всі компоненти взаємодіють напряму, без додаткових рівнів абстракції, як у мікроядерних системах. Це забезпечує високу продуктивність, проте створює певні складнощі в розробці та підтримці: будь-яка помилка в коді ядра може вплинути на всю систему.

### **Модульність ядра Linux**

Хоча ядро Linux є монолітним, воно підтримує **динамічне завантаження модулів**. Це означає, що не всі драйвери та сервіси мають бути включені до ядра під час його компіляції – вони можуть бути завантажені в систему за необхідності. Наприклад, якщо користувач підключає новий USB-пристрій, відповідний модуль драйвера може бути автоматично завантажений, без необхідності перезапуску системи.

Модулі ядра дозволяють розширювати функціональність системи без внесення змін у сам код ядра. Вони можуть бути завантажені, вивантажені або оновлені окремо, що полегшує адміністрування системи та її підтримку. Наприклад, у Linux командою `lsmod` можна переглянути список завантажених модулів, `modprobe` використовується для їх завантаження, а `rmmod` – для вивантаження.

### **Основні компоненти ядра Linux**

Ядро Linux складається з кількох основних підсистем, які відповідають за управління різними аспектами роботи системи.

1. **Планувальник процесів (Process Scheduler)** – відповідає за розподіл процесорного часу між процесами. Він використовує різні алгоритми планування для того, щоб забезпечити баланс між швидкістю виконання програм і справедливим розподілом ресурсів.
2. **Управління пам’яттю (Memory Management)** – забезпечує виділення пам’яті процесам, управління кешуванням, віртуальну пам’ять та захист адресного простору. У Linux реалізовано механізм розподілу пам’яті за принципом "on-demand", тобто процес отримує пам’ять лише тоді, коли вона йому потрібна.
3. **Файлова система (VFS – Virtual File System)** – надає уніфікований інтерфейс для роботи з різними файловими системами. Завдяки цьому Linux може працювати з різними типами файлових систем, такими як ext4, XFS, Btrfs, NTFS, FAT32, без зміни коду програм.
4. **Підсистема драйверів пристроїв (Device Drivers)** – забезпечує взаємодію ОС з апаратним забезпеченням. Кожен пристрій у Linux представлений у вигляді файлу в каталозі `/dev`, що дозволяє працювати з апаратним забезпеченням так само, як із звичайними файлами.
5. **Мережева підсистема (Networking Stack)** – відповідає за обробку мережевого трафіку, підтримку протоколів TCP/IP, керування мережевими інтерфейсами та маршрутизацію даних.
6. **Система безпеки (Security Module, SELinux, AppArmor)** – забезпечує контроль доступу до ресурсів, захист від несанкціонованого виконання коду та підтримку різних політик безпеки.

### **Ядро – це лише частина системи**

![[Pasted image 20250211165705.png]]


Хоча ядро є центральним елементом операційної системи, сама система – це набагато більше, ніж просто ядро. Повноцінна ОС GNU/Linux складається з багатьох рівнів, кожен з яких виконує певну функцію.

Ядро відповідає лише за найнижчий рівень – взаємодію з апаратним забезпеченням та управління ресурсами. Але для роботи користувача необхідні й інші компоненти, такі як **оболонка (shell)**, утиліти командного рядка, графічний інтерфейс та пакети програмного забезпечення.

Графічна оболонка, наприклад GNOME або KDE, працює поверх ядра та надає користувачам інтуїтивно зрозумілий інтерфейс. У командному режимі користувач взаємодіє із системою через **Bash або Zsh**, які дозволяють виконувати команди, запускати програми та автоматизувати робочі процеси за допомогою скриптів.

Також у складі системи є **система управління пакетами** (APT у Debian/Ubuntu, YUM/DNF у CentOS, Pacman в Arch Linux), яка дозволяє встановлювати та оновлювати програмне забезпечення без необхідності компілювати його вручну.

Щоб операційна система працювала як єдиний механізм, всі ці компоненти мають взаємодіяти між собою через стандартизовані інтерфейси. Наприклад, коли користувач відкриває веб-браузер, запит передається через оболонку, яка звертається до системних бібліотек, які у свою чергу взаємодіють з ядром, щоб виділити необхідні ресурси.

Таким чином, GNU/Linux – це не просто ядро, а ціла екосистема, що включає в себе користувацькі інтерфейси, файлову систему, мережеві сервіси, системні утиліти та додаткові програмні пакети. Саме взаємодія цих елементів робить систему повноцінною та придатною для використання у найрізноманітніших сценаріях – від серверів і суперкомп’ютерів до мобільних пристроїв та вбудованих систем. 

### **Файлова система та робота з файлами**

Файлова система – це один із найважливіших компонентів операційної системи, який відповідає за зберігання, організацію та доступ до даних. Без файлової системи всі дані на диску були б хаотично розташованими наборами бітів, що унеможливлювало б їх ефективне використання. Файлова система не тільки зберігає інформацію, а й керує її структурою, визначає права доступу, забезпечує цілісність даних та їх швидкий пошук.

У Linux усі файли організовані в єдину **ієрархічну файлову систему**, де кореневий каталог (`/`) є основою для всієї структури. У цій моделі кожен пристрій, включаючи жорсткі диски, флеш-накопичувачі та навіть мережеві ресурси, представлений у вигляді каталогу або файлу. Це означає, що у Linux немає окремих дисків C:, D:, E:, як у Windows – замість цього всі носії монтуються у певні каталоги (`/mnt`, `/media`, `/home`).

### **Типи файлових систем у Linux**

Linux підтримує велику кількість файлових систем, які можна використовувати залежно від типу пристрою та необхідних характеристик.

Найпоширенішою файловою системою в сучасних дистрибутивах Linux є **ext4 (Fourth Extended Filesystem)**. Вона забезпечує високу продуктивність, надійність і підтримку великих розмірів файлів та розділів. Крім неї, у Linux можна використовувати **XFS**, яка підходить для високонавантажених серверних систем, або **Btrfs**, що має розширені можливості управління знімками (snapshots) та перевірки цілісності даних.

Якщо необхідно працювати з флеш-накопичувачами або зовнішніми дисками, часто використовуються файлові системи **FAT32** та **exFAT**, які сумісні з Windows та macOS. Також Linux підтримує файлову систему **NTFS**, хоча вона використовується переважно в середовищі Windows.

### **Основна структура файлової системи в Linux**

Файлова система Linux організована у вигляді **ієрархічного дерева каталогів**, де кожен каталог виконує певну роль:

- **`/` (кореневий каталог)** – містить всі інші каталоги та файли.
- **`/home`** – каталог користувачів, де зберігаються їхні особисті файли та налаштування.
- **`/bin` та `/sbin`** – містять системні утиліти та команди.
- **`/etc`** – файли конфігурації системи та служб.
- **`/var`** – змінні файли, журнали (`/var/log`), кеш (`/var/cache`).
- **`/dev`** – спеціальні файли пристроїв (диски, USB, принтери).
- **`/mnt` та `/media`** – точки монтування зовнішніх носіїв.
- **`/proc` та `/sys`** – віртуальні файлові системи, що містять інформацію про запущені процеси та системні параметри.

Ця структура забезпечує логічну організацію даних і дозволяє швидко знаходити потрібні файли.
![[fJlVaulJb.png]]

### **Робота з файлами та каталогами в терміналі Linux**

Взаємодія з файловою системою у Linux зазвичай здійснюється через командний рядок, що дозволяє автоматизувати процеси та ефективно працювати з великою кількістю файлів.

Щоб перевірити вміст каталогу, використовується команда `ls`. Вона дозволяє побачити список файлів та папок у поточному місці. Додавши параметр `-l`, можна отримати детальнішу інформацію, включаючи права доступу, власника, дату зміни та розмір файлу.

Перехід між каталогами виконується командою `cd`, наприклад, `cd /home/user` відкриває домашню директорію користувача. Щоб дізнатися, в якому каталозі зараз знаходиться користувач, використовується `pwd`.

Створення файлів і папок у Linux також здійснюється за допомогою терміналу. Команда `mkdir` створює новий каталог, наприклад, `mkdir /home/user/documents`. Для створення порожнього файлу можна використати `touch`, наприклад, `touch newfile.txt`.

Щоб перемістити або перейменувати файл, використовується команда `mv`. Наприклад, `mv oldname.txt newname.txt` перейменує файл, а `mv file.txt /home/user/documents` перемістить його в інший каталог. Для копіювання файлів застосовується команда `cp`, наприклад, `cp file.txt backup.txt`. Видалення файлів здійснюється через `rm`, наприклад, `rm file.txt`, а для видалення каталогу разом із вмістом використовується `rm -r folder`.

### **Права доступу до файлів та користувачі**

Linux має гнучку систему контролю доступу до файлів, яка базується на понятті власників і груп. Кожен файл має три основні категорії доступу: **власник (user), група (group) та інші (others)**. Відповідно, є три типи прав: **читання (r), запис (w) і виконання (x)**.

Щоб переглянути права доступу, можна скористатися командою `ls -l`, яка виведе щось на зразок:

```
-rw-r--r--  1 user user  4096 Feb 11 12:30 document.txt
```

Тут `rw-r--r--` означає, що власник має право читати та змінювати файл (`rw-`), група може тільки читати (`r--`), а інші користувачі також можуть лише переглядати вміст (`r--`).

Для зміни прав доступу використовується команда `chmod`. Наприклад, `chmod 755 script.sh` надасть всім користувачам право виконання скрипта, а `chmod 600 secret.txt` дозволить лише власнику читати і змінювати файл.

Щоб змінити власника файлу, застосовується команда `chown`, наприклад, `chown user:group file.txt` змінить власника та групу для файлу.

### **Монтування файлових систем**

У Linux кожен носій даних повинен бути змонтований у файлову систему перед використанням. Для цього використовується команда `mount`. Наприклад, якщо підключений зовнішній диск `/dev/sdb1`, його можна змонтувати в `/mnt` командою `mount /dev/sdb1 /mnt`.

Щоб відключити пристрій, використовується `umount`, наприклад, `umount /mnt`.

Якщо потрібно автоматично монтувати диск при завантаженні системи, можна додати відповідний запис у файл `/etc/fstab`, який містить інформацію про всі розділи та точки монтування.

### **Partitioning, Formatting та їх зв’язок із фізичними носіями**

#### **Як дані розміщуються на фізичних носіях**

Жорсткі диски (HDD) і твердотільні накопичувачі (SSD) є основними пристроями для зберігання даних у комп’ютерах. Проте перед тим, як операційна система зможе використовувати диск, його потрібно підготувати. Цей процес включає **розбивку на розділи (partitioning)** та **форматування (formatting)**, що забезпечує правильну організацію і збереження даних.

#### **Partitioning – розбивка диска на розділи**

Фізичний диск сам по собі не є структурованим простором для зберігання даних. Щоб операційна система могла правильно працювати з носієм, диск потрібно **розбити на логічні розділи**. Partitioning визначає, які частини диска будуть використовуватися під які потреби.

Розділи бувають двох основних типів:

- **Основні розділи (Primary Partitions)** – основні розділи, з яких можна завантажувати операційну систему. У класичних таблицях розділів (MBR) можна створити до 4 основних розділів.
- **Розширені розділи (Extended Partitions) та логічні диски (Logical Partitions)** – якщо потрібно більше розділів, один із основних розділів може бути розширеним, а всередині нього створюються логічні розділи.

З появою **GPT (GUID Partition Table)** обмеження на кількість розділів знято – диск може мати **128 розділів**, і всі вони можуть бути основними.

Розбиття диска дозволяє використовувати один фізичний носій для різних цілей. Наприклад, можна мати окремий розділ для операційної системи (`/`), окремий для домашніх файлів (`/home`), а також розділ під своп (`swap`) у Linux.

#### **Форматування – створення файлової системи**

Після того як диск або його розділ створено, він ще не готовий до використання. Його потрібно **відформатувати**, що означає створення файлової системи, яка визначає, як будуть зберігатися файли.

Форматування виконує дві основні функції:

1. **Створення файлової системи** – визначає, як організовані каталоги, файли, метадані та структура збереження даних.
2. **Ініціалізація носія** – записує початкові службові дані, необхідні для роботи файлової системи.

Наприклад, коли користувач форматує флешку у файловій системі FAT32, операційна система створює структуру директорій, таблицю файлів та області для збереження інформації.

У Linux для форматування використовується команда `mkfs`, наприклад:

```
mkfs.ext4 /dev/sdb1
```

Ця команда створює файлову систему **ext4** на розділі `/dev/sdb1`.

#### **Різниця між HDD та SSD у контексті partitioning і formatting**

Жорсткі диски (HDD) мають фізичні обмеження, пов’язані з магнітними пластинами та головками читання-запису. Через це у файлових системах застосовуються механізми дефрагментації та розподілу даних для оптимізації доступу.

На відміну від HDD, твердотільні накопичувачі (SSD) працюють на основі флеш-пам’яті і не мають рухомих частин. Тому **дефрагментація для SSD не потрібна**, а навпаки – може зменшити термін служби. Замість цього у SSD використовується технологія **TRIM**, яка дозволяє контролеру SSD ефективно видаляти непотрібні блоки даних і зберігати продуктивність диска.

При форматуванні SSD важливо враховувати **вирівнювання розділів (partition alignment)** – правильне розташування початку розділу відповідно до фізичних блоків пам’яті SSD. Якщо розділи не вирівняні, це може призвести до зниження швидкодії та передчасного зносу флеш-комірок.

У Linux команда `fdisk` або `parted` допомагає створити коректно вирівняні розділи. Наприклад, створення GPT-розділу:

```
parted /dev/sdb mklabel gpt
```

#### **Як це виглядає у Linux?**

Щоб переглянути всі розділи на диску, використовується команда:

```
lsblk
```

Щоб переглянути інформацію про файлові системи:

```
df -h
```

Для створення нового розділу можна використовувати `fdisk`:

```
fdisk /dev/sdb
```

Після створення розділу його потрібно відформатувати, наприклад, у `ext4`:

```
mkfs.ext4 /dev/sdb1
```

І змонтувати у файлову систему:

```
mount /dev/sdb1 /mnt
```

Щоб зробити монтування постійним після перезавантаження, можна додати відповідний запис у `/etc/fstab`.



**Partitioning і formatting – це два ключові етапи підготовки диска до роботи. Partitioning дозволяє розділити фізичний носій на окремі частини, які можуть мати різні призначення, а форматування створює файлову систему, що визначає спосіб збереження і організації файлів. У Linux цей процес є гнучким і дозволяє легко адаптувати файлову структуру до потреб користувача чи сервера.**

### **Процеси, потоки та керування ними**

Процес – це виконувана програма, яка отримує ресурси від операційної системи. Коли користувач запускає програму, операційна система створює новий процес, який отримує унікальний ідентифікатор (PID – Process ID) і визначений набір ресурсів, включаючи пам’ять, файлові дескриптори, доступ до пристроїв та процесорний час.

ОС Linux, як і всі сучасні операційні системи, є багатозадачною, тобто дозволяє виконувати багато процесів одночасно. У ранніх операційних системах, таких як **MS-DOS**, багатозадачність була відсутня – комп’ютер міг виконувати лише одну програму за раз. Однак у **Unix** вже в 1970-х роках була реалізована концепція багатозадачності за рахунок **перемикання контексту** (context switching), коли ядро швидко переключає виконання між різними процесами, створюючи ілюзію паралельної роботи.

У Linux кожен процес має свій власний **адресний простір у пам’яті**, що означає, що він не може напряму отримати доступ до пам’яті іншого процесу без спеціальних механізмів взаємодії. Таке розділення необхідне для стабільності та безпеки системи.

### **Структура процесу в пам’яті**

Процес складається з кількох основних сегментів у пам’яті:

- **Код програми (text section)** – містить машинний код, який виконує процес.
- **Дані (data section)** – містить глобальні змінні програми.
- **Купа (heap)** – використовується для динамічного виділення пам’яті. Наприклад, якщо програма використовує `malloc()` у C, пам’ять виділяється в купі.
- **Стек (stack)** – використовується для збереження тимчасових змінних, параметрів функцій та адрес повернення при виклику функцій.

Ця модель пам’яті дозволяє кожному процесу мати ізольоване середовище виконання, але при цьому ОС забезпечує механізми взаємодії між процесами.

### **Процеси та їхні стани**

Коли процес створюється, він проходить кілька станів у своєму життєвому циклі:

1. **Створений (new)** – процес ще не запущений, але ядро виділило йому ресурси.
2. **Виконується (running)** – процес отримав доступ до процесора.
3. **Очікує (waiting)** – процес чекає на подію, наприклад, завершення операції введення/виведення.
4. **Готовий (ready)** – процес готовий до виконання, але чекає своєї черги.
5. **Завершений (terminated)** – процес закінчив виконання і звільнив свої ресурси.

![[process-states.png]]

Перемикання між станами керується **планувальником процесів (scheduler)**, який визначає, який процес отримає доступ до процесора наступним.

### **Планування процесів у Linux**

У Linux використовується **повністю справедливий планувальник (Completely Fair Scheduler, CFS)**, який розподіляє процесорний час між процесами залежно від їхньої пріоритетності та використання ресурсів. Це значне покращення порівняно з ранніми алгоритмами, такими як **Round Robin**, який просто давав кожному процесу рівний часовий слот без врахування важливості завдання.

Кожен процес має **пріоритет (nice value)**, який може бути змінений командою `nice` або `renice`. Процеси з нижчим значенням nice отримують більше процесорного часу.

Щоб переглянути список запущених процесів, використовується команда `ps`:

```
ps aux
```

Або інтерактивний перегляд процесів за допомогою `top` або `htop`:

```
top
```

### **Процеси та їхні батьки: PID та PPID**

У Linux всі процеси утворюють **дерево процесів**, де кожен процес має **батьківський процес (PPID – Parent Process ID)**. Кореневим процесом системи є **init (або systemd у сучасних дистрибутивах)**, який запускається при завантаженні ОС і є предком всіх інших процесів.

Щоб переглянути дерево процесів, можна використати:

```
pstree
```

Коли процес створює новий процес, відбувається **форкування (fork)**, тобто копіювання батьківського процесу. Це класичний механізм Unix, що дозволяє створювати нові процеси безпосередньо в пам’яті.

### **Потоки – легкі процеси**

На відміну від процесів, **потоки (threads)** – це "легковагові" виконувані одиниці всередині одного процесу. Вони мають спільний адресний простір і ресурси, що робить їх взаємодію значно швидшою за між процесну.

Багатопотокові програми дозволяють ефективно використовувати ресурси багатоядерних процесорів. Наприклад, у браузері один потік може відповідати за відображення сторінки, інший – за завантаження файлів, а ще один – за обробку користувацьких команд.

У Linux реалізація потоків заснована на **POSIX Threads (pthreads)**, які дозволяють створювати, керувати та синхронізувати потоки всередині процесів.

![[F4-12.jpg]]

### **Фонові процеси та демонічні служби**

У Linux можна запустити процес у фоні, додавши `&` у кінці команди:

```
firefox &
```

Щоб переглянути фонові процеси, використовується команда `jobs`.

Деякі процеси працюють у фоні постійно – вони називаються **демонами (daemons)**. Наприклад, `sshd` – це демон, який відповідає за віддалений доступ через SSH. Демони зазвичай мають назви, що закінчуються на `d` (`systemd`, `crond`, `nginx`), і запускаються під час старту системи.

Щоб керувати службами в сучасних дистрибутивах, використовується `systemctl`:

```
systemctl status sshd
```

### **Завершення та керування процесами**

Якщо процес завис або споживає забагато ресурсів, його можна примусово завершити командою `kill`, наприклад:

```
kill -9 PID
```

Або за іменем процесу:

```
pkill firefox
```

Утиліта `htop` дозволяє інтерактивно керувати процесами, змінювати їхні пріоритети та завершувати їх безпосередньо через термінал.

### **Міжпроцесна взаємодія (IPC)**

Процеси часто повинні обмінюватися даними між собою. У Linux існують різні механізми **міжпроцесної взаємодії (Inter-Process Communication, IPC)**:

- **Черги повідомлень (message queues)** – процеси можуть надсилати повідомлення один одному через системні черги.
- **Семафори (semaphores)** – використовуються для синхронізації між процесами.
- **Спільна пам’ять (shared memory)** – дозволяє процесам працювати з одними й тими ж даними напряму, що значно пришвидшує обмін інформацією.
- **Сокети (sockets)** – використовуються для взаємодії між процесами як у межах одного комп’ютера, так і через мережу.

Керування процесами – це основна функція будь-якої операційної системи. У Linux система планування та управління процесами розвинена і дозволяє ефективно розподіляти ресурси, забезпечувати стабільність та продуктивність. Завдяки механізмам потоків, IPC і фонових служб Linux здатний обробляти складні багатозадачні сценарії як на персональних комп’ютерах, так і на високонавантажених серверах.

### **Переривання, багатозадачність, багатопроцесність і планувальник процесів**

#### **Що таке механізм переривань?**

Переривання (interrupts) – це спеціальний механізм, який дозволяє процесору **тимчасово зупинити виконання поточного процесу** та перейти до обробки події, що надійшла. Після завершення обробки процесор може повернутися до виконання попереднього завдання з того місця, де він зупинився.

Без цього механізму процесору доводилося б постійно перевіряти (polling), чи відбулися певні події, що було б неефективним. Завдяки перериванням система може швидко реагувати на події в режимі реального часу, наприклад, коли користувач натискає клавішу на клавіатурі або приходять дані з мережі.

Переривання відіграють **ключову роль у багатозадачності**, оскільки дозволяють **операційній системі керувати перемиканням між процесами** та забезпечують взаємодію з периферійними пристроями.

---

### **Типи переривань**

1. **Апартні (hardware interrupts)** – надходять від пристроїв, таких як клавіатура, миша, мережеві карти, таймери. Приклад: натискання клавіші на клавіатурі викликає переривання, яке передається ядру ОС.
2. **Програмні (software interrupts)** – викликаються програмами або операційною системою, наприклад, через системні виклики (`syscall`).
3. **Переривання від таймера (timer interrupts)** – системний таймер надсилає регулярні переривання, що дозволяє планувальнику ОС перемикатися між процесами (multitasking).

---

### **Переривання і багатозадачність**

Багатозадачність (multitasking) – це здатність ОС **одночасно виконувати кілька процесів**, переключаючись між ними. У сучасних ОС (наприклад, Linux) багатозадачність є **витісняючою (preemptive multitasking)**, тобто ядро **самостійно вирішує, коли слід перемикатися між процесами**, замість того щоб чекати, поки процес сам завершиться.

Як тут працює механізм переривань?

- **Системний таймер (timer interrupt)** періодично (зазвичай кожні 1–10 мс) надсилає сигнал процесору.
- Коли приходить таймерне переривання, **ядро виконує контекстне перемикання (context switch)** – зберігає стан поточного процесу, вибирає інший процес у черзі планувальника і відновлює його стан.
- Завдяки цьому користувач може, наприклад, слухати музику та одночасно працювати в браузері – ОС перемикається між процесами так швидко, що це виглядає як паралельна робота.

---

### **Переривання і багатопроцесність**

Багатопроцесність (multiprocessing) означає, що у системі є **декілька фізичних або логічних процесорів**, які можуть виконувати процеси **паралельно**, а не просто перемикатися між ними.

У цьому випадку **планувальник процесів (scheduler)** повинен розподіляти навантаження між доступними ядрами CPU. Тут механізм переривань грає важливу роль:

- Коли процес, що працює на ядрі CPU, виконує **операцію введення-виведення (I/O)**, він викликає **системний виклик (syscall)**, який призводить до **програмного переривання**.
- Якщо поточний процес заблокований, очікуючи на завершення введення/виведення (наприклад, читання файлу з диска або отримання даних з мережі), ядро може переключитися на інший процес.
- Коли пристрій завершив свою операцію (наприклад, мережевий адаптер отримав пакет), надходить **апаратне переривання**, яке повідомляє процесор, що можна продовжити виконання відповідного процесу.

Таким чином, багатопроцесність не просто використовує кілька ядер CPU, а й активно взаємодіє з механізмом переривань для **ефективного планування завдань і використання ресурсів**.

---

### **Як переривання працюють у контексті введення-виведення (I/O)?**

#### **1. Клавіатура і миша**

Коли користувач натискає клавішу або рухає мишу:

- Контролер клавіатури/миші генерує **апаратне переривання**.
- Процесор тимчасово зупиняє поточне завдання, викликає відповідний драйвер у ядрі ОС.
- Драйвер отримує дані, розпізнає натиснуту клавішу або рух миші та передає інформацію у відповідний буфер.
- ОС передає ці дані активному додатку (наприклад, текстовому редактору).

Без механізму переривань ОС довелося б **постійно** опитувати клавіатуру, що витрачало б зайві ресурси.

#### **2. Мережевий інтерфейс (Ethernet, Wi-Fi)**

Коли приходять дані через мережу:

- Мережевий адаптер отримує новий пакет і викликає **апаратне переривання**.
- ОС зупиняє поточний процес, викликає драйвер мережевого адаптера, який копіює дані у буфер.
- ОС передає ці дані відповідному процесу (наприклад, веб-браузеру).

Якби переривань не було, ОС довелося б постійно "запитувати" мережевий адаптер, чи прийшли нові дані, що значно сповільнило б роботу системи.

#### **3. Жорсткий диск або SSD**

Коли програма запитує читання файлу:

- Відбувається **системний виклик (`read()`)**, що спричиняє **програмне переривання**.
- Ядро передає запит драйверу файлової системи, який ініціює операцію читання.
- Процес блокується, очікуючи завершення операції.
- Коли диск передає дані, він генерує **апаратне переривання**.
- ОС пробуджує процес, що очікував на читання, і він продовжує роботу.

У старих системах без переривань CPU мусив би **постійно чекати на завершення операції диска**, що робило б виконання інших процесів неможливим.

---

### **Як планувальник процесів використовує переривання?**

ОС має **планувальник процесів (scheduler)**, який використовує **таймерні переривання**, щоб перемикати контекст між завданнями:

4. **Планувальник отримує переривання від таймера (наприклад, кожні 5 мс).**
5. **Збереження стану поточного процесу.**
6. **Вибір нового процесу з черги на виконання.**
7. **Завантаження контексту нового процесу та його запуск.**

Якщо б **переривання не було**, система не змогла б ефективно переключатися між завданнями, і один процес міг би займати весь процесорний час.

---


Механізм переривань є основою багатозадачності та ефективної роботи ОС. Він дозволяє системі швидко реагувати на події з периферійних пристроїв, забезпечує перемикання між процесами та сприяє ефективному розподілу ресурсів у багатоядерних системах.

Без переривань **багатозадачність, введення-виведення та планування процесів працювали б набагато повільніше**, а сама ОС була б значно менш ефективною. Linux та інші Unix-подібні системи використовують цей механізм для **гнучкого керування процесами, ефективної роботи серверів і швидкого реагування на зовнішні події**.


### **Взаємодія користувача з операційною системою: термінал, командний рядок та оболонки**

Операційна система забезпечує два основні способи взаємодії з користувачем: **графічний інтерфейс (GUI, Graphical User Interface)** та **командний інтерфейс (CLI, Command-Line Interface)**.

Графічний інтерфейс – це візуальна оболонка, що дозволяє користувачу керувати системою за допомогою миші та клавіатури, використовуючи кнопки, вікна та меню. Прикладом таких інтерфейсів є **Windows Explorer**, **GNOME** або **KDE Plasma** у Linux.
![[kubuntu.png]]

Однак, у серверних системах, а також у професійному використанні Linux, основним способом роботи залишається **командний рядок (CLI)**, який забезпечує значно більшу гнучкість, контроль та автоматизацію завдань.
![[Tmux-powerline.png]]

### **Оболонки командного рядка (Shells) у Linux**

Оболонка (shell) – це інтерфейс між користувачем і ядром операційної системи, який дозволяє виконувати команди, запускати процеси та писати скрипти.

У Linux існує кілька популярних оболонок:

- **Bash (Bourne Again Shell)** – стандартна оболонка для більшості дистрибутивів Linux. Має широкий набір можливостей, підтримує автозавершення команд, роботу зі змінними середовища та скриптами.
- **Zsh (Z Shell)** – розширена альтернатива Bash з покращеними можливостями автодоповнення та кастомізації.
- **Fish (Friendly Interactive Shell)** – оболонка з інтуїтивним автодоповненням та вбудованими підказками.
- **Dash (Debian Almquist Shell)** – мінімалістична та легка оболонка, що часто використовується для системних скриптів.

### tmux

**tmux (Terminal Multiplexer)** – це інструмент, що дозволяє **запускати та керувати кількома сеансами терміналу** в одному вікні. Він дає змогу розділяти екран, створювати фонові сесії та перемикатися між ними. Це корисно для роботи на сервері або одночасного виконання кількох процесів без відкриття нових вікон терміналу.

Основні команди:

- `tmux new -s session_name` – створити нову сесію.
- `tmux attach -t session_name` – підключитися до сесії.
- `tmux detach` (`Ctrl + B`, потім `D`) – вийти з сесії без її завершення.
- `tmux list-sessions` – переглянути активні сесії.

tmux є незамінним для адміністраторів і розробників, які працюють у терміналі.

Щоб дізнатися, яка оболонка використовується в системі, можна виконати:

```
echo $SHELL
```

Перехід між оболонками можливий простим запуском відповідної команди, наприклад:

```
zsh
```

### **Базові команди Linux для роботи з терміналом**

Термінал у Linux дозволяє виконувати команди, працювати з файлами, налаштовувати систему та автоматизувати завдання.

#### **Навігація по файловій системі**

Щоб дізнатися, в якому каталозі знаходиться користувач, використовується команда:

```
pwd
```

Переміщення між каталогами здійснюється командою `cd` (change directory):

```
cd /home/user/documents
```

Щоб повернутися на рівень вище, можна використати `..`:

```
cd ..
```

Перегляд вмісту каталогу виконується командою `ls`:

```
ls -l
```

Опція `-l` виводить детальну інформацію про файли, включаючи права доступу, власника та дату модифікації.

#### **Робота з файлами та каталогами**

Створення нового каталогу:

```
mkdir new_folder
```

Створення порожнього файлу:

```
touch file.txt
```

Копіювання файлу або каталогу:

```
cp file.txt backup.txt
```

Переміщення або перейменування файлу:

```
mv file.txt newname.txt
```

Видалення файлу:

```
rm file.txt
```

Видалення каталогу з усім вмістом:

```
rm -r folder_name
```

#### **Перегляд вмісту файлів**

Щоб переглянути вміст файлу, можна використати кілька команд:

```
cat file.txt     # Відобразити весь файл
less file.txt    # Перегляд з прокруткою
tail -n 10 file.txt  # Останні 10 рядків файлу
head -n 10 file.txt  # Перші 10 рядків файлу
```

#### **Пошук файлів і тексту в них**

Пошук файлу за назвою у певному каталозі виконується командою `find`:

```
find /home -name "file.txt"
```

Щоб знайти всі файли `.log`, створені за останній день:

```
find /var/log -name "*.log" -mtime -1
```

Для пошуку тексту у файлі використовується `grep`:

```
grep "помилка" logfile.log
```

Щоб знайти всі рядки, які містять певне слово у всіх файлах каталогу:

```
grep -r "error" /var/log/
```

#### **Робота з процесами**

Перегляд усіх активних процесів у системі:

```
ps aux
```

Або інтерактивний моніторинг ресурсів через `top`:

```
top
```

Щоб завершити процес за його ідентифікатором (PID), використовується команда `kill`:

```
kill -9 1234
```

Або завершити процес за назвою:

```
pkill firefox
```

Щоб запустити команду у фоновому режимі, використовується `&`:

```
firefox &
```

Перевести запущений процес у фоновий режим можна за допомогою `bg`, а повернути в передній – `fg`.

### **Оболонки та змінні середовища**

У терміналі можна використовувати змінні середовища для збереження інформації, наприклад:

```
export MY_VAR="Hello, world!"
echo $MY_VAR
```

Щоб змінні зберігалися після перезавантаження, їх потрібно додати до файлу `.bashrc` або `.bash_profile`.

Переглянути всі змінні середовища можна командою:

```
env
```

### **Редагування файлів у терміналі**

У Linux існують кілька текстових редакторів для роботи у терміналі:

- `nano` – простий і зручний редактор:
    
    ```
    nano file.txt
    ```
    
- `vim` – потужний редактор для досвідчених користувачів:
    
    ```
    vim file.txt
    ```
    

Щоб зберегти зміни у `nano`, натискається `Ctrl + O`, потім `Enter`, а для виходу – `Ctrl + X`.

### **Автоматизація через Bash-скрипти**

Оболонка Bash дозволяє писати сценарії (скрипти), що автоматизують виконання команд. Простий скрипт виглядає так:

```bash
#!/bin/bash
echo "Привіт, це мій перший Bash-скрипт!"
```

Щоб зробити його виконуваним, потрібно змінити права доступу:

```
chmod +x script.sh
```

І запустити:

```
./script.sh
```

## Приклад

Bash-скрипт, який запитує API ПриватБанку для отримання поточного курсу долара до гривні та записує результати у файл логів.

```bash
#!/bin/bash

# URL API ПриватБанку для отримання курсу валют
API_URL="https://api.privatbank.ua/p24api/pubinfo?json&exchange&coursid=5"

# Файл для збереження логів
LOG_FILE="exchange_rate.log"

# Виконання запиту до API та отримання курсу долара
response=$(curl -s "$API_URL")

# Перевірка чи отримано відповідь
if [[ -z "$response" ]]; then
    echo "$(date '+%Y-%m-%d %H:%M:%S') - Не вдалося отримати дані від API" | tee -a "$LOG_FILE"
    exit 1
fi

# Витягнення курсу USD до UAH за допомогою jq
USD_RATE=$(echo "$response" | jq -r '.[] | select(.ccy=="USD") | .sale')

# Перевірка чи курс було отримано
if [[ -z "$USD_RATE" ]]; then
    echo "$(date '+%Y-%m-%d %H:%M:%S') - Не вдалося знайти курс USD/UAH у відповіді API" | tee -a "$LOG_FILE"
    exit 1
fi

# Запис результату у лог
echo "$(date '+%Y-%m-%d %H:%M:%S') - Поточний курс USD/UAH: $USD_RATE" | tee -a "$LOG_FILE"

# Виведення інформації
echo "Результати записано у файл: $LOG_FILE"
```

### **Як запустити скрипт?**

6. Зробити файл виконуваним:
    
    ```bash
    chmod +x check_usd_rate.sh
    ```
    
7. Запустити:
    
    ```bash
    ./check_usd_rate.sh
    ```
    

⚠ **Примітка:** Скрипт використовує `jq` для обробки JSON. Якщо `jq` не встановлений, його можна встановити за допомогою:

- Ubuntu/Debian:

  ```bash
  sudo apt install jq
   ```
- macOS:

  ```bash
  brew install jq
   ```

**Командний рядок є ключовим інструментом у Linux та інших Unix-подібних системах. Він дозволяє швидко виконувати операції, автоматизувати завдання та ефективно керувати системою. Для новачків він може здатися складним, але з часом стає потужним інструментом, що значно розширює можливості користувача.**

### **Пакетні менеджери в Linux: встановлення, оновлення та управління програмами**

#### **Що таке пакетний менеджер?**

Пакетний менеджер – це програма, яка спрощує встановлення, оновлення, видалення та управління програмним забезпеченням у Linux. У більшості дистрибутивів користувачам не потрібно вручну завантажувати та компілювати програми – пакетний менеджер автоматично завантажує потрібні файли, вирішує залежності (тобто встановлює всі необхідні бібліотеки) і забезпечує оновлення до нових версій.

У Windows аналогом пакетного менеджера можна вважати **Microsoft Store**, а також сторонні рішення, такі як **Chocolatey**.

#### **Основні пакетні менеджери в Linux**

Різні дистрибутиви використовують свої пакетні менеджери:

- **Debian/Ubuntu** → `apt` (Advanced Package Tool)
- **Arch Linux** → `pacman`
- **Fedora/CentOS/RHEL** → `dnf` (або застарілий `yum`)
- **openSUSE** → `zypper`
- **Gentoo** → `emerge`

Щоб знайти пакетний менеджер у системі, можна виконати:

```
which apt pacman dnf zypper emerge
```

Якщо команда повернула шлях, це означає, що відповідний пакетний менеджер встановлений.

#### **Робота з пакетами у Debian/Ubuntu (APT)**

Щоб оновити список доступних пакетів у Debian/Ubuntu, використовується команда:

```
sudo apt update
```

Оновлення всіх встановлених програм до нових версій:

```
sudo apt upgrade
```

Щоб встановити певний пакет, наприклад, текстовий редактор `vim`:

```
sudo apt install vim
```

Видалення програми:

```
sudo apt remove vim
```

Щоб знайти програму, використовується `apt search`:

```
apt search firefox
```

Якщо потрібно очистити кеш завантажених пакетів та звільнити місце на диску:

```
sudo apt autoremove
sudo apt clean
```

---

### **Суперкористувач (root) та команда `sudo`**

#### **Що таке root?**

У Linux та Unix-подібних операційних системах існує спеціальний обліковий запис **суперкористувача (root)**, який має повний контроль над системою. Root-акаунт може змінювати критично важливі файли, керувати користувачами, встановлювати та видаляти програми, а також змінювати налаштування безпеки.

Root має **необмежені привілеї**, тому неправильне використання цього облікового запису може пошкодити систему.

Щоб дізнатися, хто зараз виконує команди в терміналі, можна використати команду:

```
whoami
```

Якщо відповідь `root`, це означає, що ви працюєте як суперкористувач.

#### **Вхід у root-режим**

У багатьох системах можна увійти як root, ввівши команду:

```
su
```

Після цього система попросить пароль адміністратора. Якщо успішно, зміниться промт (`#` замість `$`), що означає, що ви працюєте в привілейованому режимі.

Щоб вийти з режиму root, достатньо виконати:

```
exit
```

Однак у багатьох сучасних дистрибутивах, таких як Ubuntu, root-акаунт **за замовчуванням вимкнено** з міркувань безпеки. Натомість використовується команда `sudo`, яка дозволяє виконувати команди з привілеями root без повного входу в root-режим.

---

### **Що таке `sudo` і як його використовувати?**

`sudo` (SuperUser Do) – це команда, яка дозволяє **звичайним користувачам тимчасово виконувати команди з правами root**. На відміну від `su`, `sudo` вимагає введення пароля кожного разу, коли запускається команда з підвищеними привілеями.

Наприклад, якщо користувач хоче оновити список пакетів у Debian або Ubuntu, він використовує:

```
sudo apt update
```

Система попросить ввести пароль користувача (не root). Якщо пароль правильний, команда виконається.

#### **Чому використовується `sudo` замість входу в root?**

8. **Безпека** – `sudo` дозволяє надавати привілеї на окремі команди, а не на всю сесію.
9. **Логування** – всі команди, виконані через `sudo`, записуються у `/var/log/auth.log`, що дозволяє відстежити, хто і що змінив у системі.
10. **Захист від помилок** – помилка у root-режимі може зруйнувати систему. Використання `sudo` зменшує ймовірність серйозних наслідків.

---

### **Налаштування `sudo` та група sudoers**

У Linux існує група **sudoers**, члени якої можуть використовувати `sudo`. Дізнатися, чи є користувач у групі sudo, можна командою:

```
groups
```

Якщо у списку є `sudo` або `wheel` (в Arch/Fedora), значить, користувач має адміністративні права.

Щоб додати користувача до цієї групи (наприклад, `user1`), root-адміністратор може виконати:

```
usermod -aG sudo user1
```

Файл конфігурації `sudo` знаходиться у `/etc/sudoers`. Його редагування виконується через:

```
sudo visudo
```

Щоб дозволити певному користувачу виконувати всі команди без введення пароля, у файл `/etc/sudoers` можна додати рядок:

```
user1 ALL=(ALL) NOPASSWD: ALL
```

Проте таке налаштування **зменшує рівень безпеки**, тому його використовують лише в особливих випадках.


### **Класифікація операційних систем**

Операційні системи поділяються за різними критеріями: за кількістю користувачів, типом керування процесами, архітектурою, сферою використання тощо. Розуміння цих відмінностей допомагає краще усвідомити, чому різні ОС підходять для різних завдань і чому, наприклад, Linux домінує у серверному сегменті, тоді як Windows – серед десктопних користувачів.

---

### **Класифікація за кількістю користувачів**

- **Однокористувацькі ОС (Single-user OS)** – система, в якій у певний момент часу може працювати тільки один користувач. Такими були ранні версії **MS-DOS** та **Mac OS Classic**. Хоча сучасні десктопні ОС (Windows, macOS, Linux) орієнтовані на одного основного користувача, вони підтримують багатокористувацький режим через зміну профілів або віддалений доступ.
    
- **Багатокористувацькі ОС (Multi-user OS)** – дозволяють кільком користувачам одночасно працювати в системі, розподіляючи ресурси між ними. Прикладами таких систем є **Unix**, **Linux**, **Windows Server**, які використовуються на серверах для віддаленої роботи кількох користувачів одночасно.
    

---

### **Класифікація за кількістю виконуваних завдань**

- **Однозадачні (Single-tasking)** – ОС може виконувати лише одну програму за раз. Наприклад, у **MS-DOS** користувач запускав одну програму, і поки вона не завершилася, інші команди виконати було неможливо.
    
- **Багатозадачні (Multitasking)** – ОС може виконувати багато процесів одночасно. Сучасні ОС, такі як Linux, Windows, macOS, використовують **витісняючу багатозадачність (preemptive multitasking)**, коли ядро перемикається між процесами, виділяючи їм певний час процесора.
    

---

### **Класифікація за способом обробки задач**

- **ОС реального часу (RTOS – Real-Time Operating System)** – такі системи використовуються у критичних застосуваннях, де важливе жорстке дотримання часових обмежень. Наприклад, **QNX**, **VxWorks**, **RTLinux** застосовуються в авіаційних системах, робототехніці, промисловому обладнанні.
    
- **ОС загального призначення (General-Purpose OS)** – універсальні операційні системи, що використовуються на персональних комп’ютерах, серверах і мобільних пристроях. Приклади: **Windows, Linux, macOS, Android, iOS**.
    

---

### **Класифікація за архітектурою**

- **Мейнфреймові ОС** – працюють на великих обчислювальних системах і підтримують сотні або тисячі одночасних користувачів. Приклади: **IBM z/OS**, **UNIX для мейнфреймів**.
    
- **Серверні ОС** – оптимізовані для роботи в режимі сервера, надаючи сервіси для клієнтів, керуючи мережевими запитами, базами даних, хмарними обчисленнями. Приклади: **Linux (Ubuntu Server, CentOS, Debian), Windows Server**.
    
- **Десктопні ОС** – використовуються на персональних комп’ютерах. Основна увага приділяється зручності користувача, сумісності з програмним забезпеченням. Приклади: **Windows, macOS, настільні дистрибутиви Linux (Ubuntu, Fedora, Manjaro)**.
    
- **Мобільні ОС** – оптимізовані для смартфонів і планшетів. Приклади: **Android, iOS**.
    
- **Вбудовані ОС (Embedded OS)** – працюють на мікроконтролерах та спеціалізованих пристроях: **FreeRTOS, Zephyr, Embedded Linux**.
    

---

### **Чому Linux домінує у серверному сегменті?**

Серед серверних ОС Linux є найбільш популярною завдяки **стабільності, безпеці та гнучкості**. На відміну від Windows Server, який часто потребує графічного інтерфейсу та регулярного оновлення з перезавантаженням, Linux можна повністю адмініструвати через термінал, а оновлення можна виконувати без зупинки сервісів. Також Linux має відкритий вихідний код, що дозволяє компаніям налаштовувати його під власні потреби.

