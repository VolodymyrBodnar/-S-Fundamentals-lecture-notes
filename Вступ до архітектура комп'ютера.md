### Процесор: детальний огляд "мозку" комп'ютера

Центральний процесор (CPU) є серцем будь-якої обчислювальної системи. Це складна мікросхема, яка фактично виконує команди, що містяться в програмах, перетворюючи код високого рівня на конкретні фізичні операції. Щоб зрозуміти, як він це робить, потрібно зазирнути всередину і познайомитися з його ключовими функціональними блоками.

#### Блок керування (Control Unit) — диригент оркестру

Уявіть собі блок керування (CU) як головного диригента в процесорі.Його завдання — не виконувати обчислення, а керувати всіма іншими компонентами, віддаючи їм точні та своєчасні накази]Він зчитує інструкції з пам'яті, одну за одною, розшифровує їх, щоб зрозуміти, що саме потрібно зробити, і потім надсилає відповідні керуючі сигнали до арифметико-логічного пристрою, регістрів та інших частин системи. Саме блок керування забезпечує злагоджену та послідовну роботу всього процесора.

#### Регістри — надшвидка пам'ять "під рукою"

Всередині процесора є власні, дуже маленькі, але надзвичайно швидкі комірки пам'яті, які називаються **регістрами**. Вони потрібні для тимчасового зберігання даних та інструкцій, які використовуються безпосередньо в момент обчислень. Доступ до регістрів є миттєвим, на відміну від доступу до значно повільнішої оперативної пам'яті. Серед безлічі регістрів є два, що відіграють критично важливу роль у виконанні програм.

* **Лічильник команд (Program Counter, PC):** Цей регістр є навігатором процесора. Він завжди містить **адресу в пам'яті наступної інструкції**, яку потрібно буде виконати. Щойно процесор зчитує чергову інструкцію, значення в лічильнику команд автоматично збільшується, вказуючи на наступну комірку пам'яті. Таким чином, PC дозволяє процесору послідовно рухатись програмою, завжди "знаючи", куди йти далі.

* **Регістр інструкцій (Instruction Register, IR):** Якщо PC вказує, звідки брати наступну команду, то IR — це місце, де ця команда тимчасово зберігається після зчитування з пам'ят. Коли інструкція завантажена в IR, блок керування аналізує її вміст, щоб визначити, які дії потрібно виконати. Регістр інструкцій діє як "робочий стіл" для поточної задачі, дозволяючи процесору сфокусуватися на виконанні однієї команди за раз.

#### Арифметико-логічний пристрій (ALU) — головний обчислювач

Арифметико-логічний пристрій (АЛУ) — це та частина процесора, де безпосередньо відбувається "магія" обчислень. Він відповідає за виконання всіх арифметичних (наприклад, додавання, віднімання) та логічних (наприклад, порівняння) операцій над даними.

#### Цикл роботи процесора та його ритм

Весь процес роботи CPU є циклічним і синхронізованим. **Тактовий генератор** задає ритм, випускаючи мільярди імпульсів на секунду. З кожним таким імпульсом (тактом) процесор виконує крок у своєму фундаментальному робочому циклі, який складається з чотирьох етапів:

1.  **Читання (Fetch):** Процесор, використовуючи адресу з лічильника команд (PC), зчитує інструкцію з оперативної пам'яті та завантажує її в регістр інструкцій (IR).
2.  **Декодування (Decode):** Блок керування аналізує інструкцію, що знаходиться в IR, щоб визначити, яку операцію потрібно виконати.
3. **Виконання (Execute):** Команда передається на виконання. Найчастіше це означає, що АЛУ проводить необхідні обчислення над даними, взятими з регістрів.
4.  **Запис (Write-back):** Результат операції записується назад у відповідний регістр або в комірку оперативної пам'яті.

Цей чотириетапний цикл повторюється безперервно для кожної нової інструкції, дозволяючи комп'ютеру виконувати найскладніші програми, розбиваючи їх на послідовність простих, чітко визначених кроків.
#### Переривання
Механізм переривань — це фундаментальний спосіб, за допомогою якого процесор реагує на термінові події, що походять від інших компонентів системи або від самого програмного коду. Уявіть, що процесор читає довгу книгу (виконує програму), і тут лунає дзвінок у двері (надходить сигнал переривання). Процесор не ігнорує дзвінок, але й не кидає книгу абияк. Він ставить закладку на тому місці, де зупинився (зберігає свій поточний стан, включно з адресою наступної інструкції з лічильника команд), і йде відчиняти двері (обробляє переривання). Виконавши те, що було потрібно, він повертається до книги, знаходить свою закладку і продовжує читання з того самого місця, наче нічого й не сталося. Цей процес дозволяє процесору ефективно керувати багатьма задачами одночасно, не пропускаючи важливі зовнішні події.

Існує кілька типів переривань, що залежать від їхнього джерела. **Апаратні переривання** генеруються фізичними пристроями: наприклад, коли ви натискаєте клавішу на клавіатурі або коли мережева карта отримує новий пакет даних, відповідний пристрій посилає сигнал процесору, вимагаючи уваги. **Програмні переривання** та **виключення** виникають всередині самої програми. Це може бути як запланований виклик, коли програма звертається до операційної системи за певною послугою (наприклад, для читання файлу), так і результат помилки під час виконання, як-от ділення на нуль або спроба доступу до неіснуючої комірки пам'яті. Саме механізм переривань (зокрема, від системного таймера) лежить в основі багатозадачності, дозволяючи операційній системі регулярно "перемикати" процесор між різними програмами, створюючи ілюзію їхньої одночасної роботи.

### **Фізико-математичні основи роботи процесора**

Щоб по-справжньому зрозуміти, як працює процесор, недостатньо знати про його блоки. Потрібно спуститися на ще глибший рівень — до фундаментальних законів математики та фізики, які роблять обчислення можливими. Саме тут абстрактні ідеї про команди та дані перетворюються на реальні фізичні процеси.

#### **Математичні основи: логіка в серці обчислень**

В основі всіх без винятку операцій, які виконує процесор, лежить елегантний і простий розділ математики — **булева алгебра**. Це система, що оперує лише двома значеннями: "істина" (True), яке представляється як 1, та "хиба" (False), яке представляється як 0. Вся складність сучасних обчислень зводиться до маніпуляцій з цими двома цифрами.

Арифметико-логічний пристрій (АЛУ) процесора побудований не з калькуляторів, а з мільйонів мікроскопічних електронних схем, що називаються **логічними вентилями**. Існує три базові типи вентилів:

- **"І" (AND):** Видає 1 на виході лише тоді, коли на _обидва_ його входи подається 1.
    
- **"АБО" (OR):** Видає 1, якщо хоча б на _один_ із його входів подається 1.
    
- **"НЕ" (NOT):** Це інвертор. Він просто змінює вхідний сигнал на протилежний (1 стає 0, а 0 стає 1).
    

Здається, що це дуже примітивні операції. Проте, комбінуючи ці три прості вентилі у величезні та складні схеми, інженери створюють так звані **суматори**, які можуть виконувати операцію додавання двійкових чисел. А оскільки будь-яку іншу арифметичну операцію (віднімання, множення, ділення) можна звести до послідовності додавань та логічних зсувів, процесор отримує здатність виконувати всю сучасну математику1111. Кожне обчислення — це лише неймовірно швидка послідовність мільярдів простих логічних кроків.

#### **Фізичні основи: від піску до думок**

Математичні принципи були б марними без фізичного втілення. "Серцем" сучасної електроніки і, зокрема, процесорів є **транзистор** — найважливіший винахід XX століття.

Уявіть собі транзистор як мікроскопічний вимикач світла, керований електрикою. Він може перебувати у двох станах:

- **"Відкритий" (On):** Пропускає через себе електричний струм. Цей стан фізично представляє логічну **1**.

- **"Закритий" (Off):** Не пропускає струм. Цей стан представляє логічний **0**.

Процесори виготовляються з кремнію — напівпровідника, який після спеціальної обробки дозволяє створювати на його поверхні мільярди таких крихітних транзисторів. Логічні вентилі ("І", "АБО", "НЕ"), про які йшлося вище, фізично є простою комбінацією з кількох таких транзисторів.

Таким чином, коли процесор виконує інструкцію, насправді відбувається наступне: блок керування посилає електричні сигнали на певні групи транзисторів, змушуючи їх перемикатися в стан "On" або "Off". Це, у свою чергу, змінює стан логічних вентилів, що призводить до виконання арифметичних чи логічних операцій в АЛУ.

Весь цей процес — скоординоване перемикання мільярдів транзисторів мільярди разів на секунду під ритм тактового генератора — і є фізичною сутністю роботи процесора. Це дивовижний шлях від базових законів фізики до здатності комп'ютера виконувати складні програми, відтворювати відео або спілкуватися з нами.


### Крок 1: Транзистор — це фізичний вимикач

На фізичному рівні транзистор — це крихітний пристрій, який може пропускати або не пропускати через себе електричний струм. Уявіть його як вимикач світла, але керований не пальцем, а іншим електричним сигналом.

Він має два основні фізичні стани:

- **Стан "ВВІМКНЕНО" (On):** Через транзистор іде струм.
    
- **Стан "ВИМКНЕНО" (Off):** Струм через транзистор не іде (ланцюг розірваний).
    

На цьому етапі немає ніякої математики, лише чиста фізика напівпровідників.

### Крок 2: Від фізики до математики — створюємо абстракцію

Тепер починається найважливіше. Інженери та математики домовились про **умовне позначення (абстракцію)**:

- Фізичному стану "ВВІМКНЕНО" (On) ми присвоюємо математичне значення **1**.

- Фізичному стану "ВИМКНЕНО" (Off) ми присвоюємо математичне значення **0**.

Тобто **0 та 1 — це не те, з чого складається транзистор, а лише мітки, якими ми позначаємо його реальний фізичний стан.** Це мова, якою ми описуємо поведінку мільярдів таких вимикачів.

### Крок 3: Реалізація математики за допомогою фізики

Тепер, коли у нас є фізичний об'єкт, стан якого ми можемо описати математично (0 або 1), ми можемо почати будувати з цих об'єктів схеми, які будуть поводитися за законами математичної логіки.

**Приклад: Як реалізувати логічний вентиль "І" (AND)**

Математично операція "І" видає 1 лише тоді, коли обидва входи дорівнюють 1. Як це зробити фізично? Дуже просто — з'єднати два транзистори **послідовно**, один за одним.

Уявіть ланцюжок з двох вимикачів, що йдуть до лампочки:

`Джерело струму ---> [Транзистор 1] ---> [Транзистор 2] ---> Лампочка`

Щоб лампочка загорілася (що представляє вихід **1**), струм має пройти через _обидва_ транзистори.

- Якщо **Транзистор 1** = "On" (**1**) **І** **Транзистор 2** = "On" (**1**), струм пройде, і на виході буде **1**.
    
- Якщо хоча б один з них буде "Off" (**0**), ланцюг буде розірваний, струм не пройде, і на виході буде **0**.
    

Таким чином, ми щойно **фізично** реалізували математичну операцію "І". Ми створили схему, поведінка якої повністю відповідає таблиці істинності для "І".

|Вхід 1 (стан Транзистора 1)|Вхід 2 (стан Транзистора 2)|Вихід (чи горить лампочка)|
|---|---|---|
|0 (Off)|0 (Off)|0 (Не горить)|
|0 (Off)|1 (On)|0 (Не горить)|
|1 (On)|0 (Off)|0 (Не горить)|
|1 (On)|1 (On)|1 (Горить)|

### **Логічний вентиль "АБО" (OR)**

**Математичне правило:** Операція "АБО" видає **1**, якщо хоча б **один** із її входів дорівнює **1**.

**Фізична реалізація:** Якщо для вентиля "І" ми з'єднували транзистори послідовно (один за одним), то для "АБО" ми з'єднаємо їх **паралельно**.

Уявіть, що до нашої лампочки ведуть два паралельні шляхи. На кожному шляху стоїть по одному транзистору-вимикачу.
```
                     / ---> [Транзистор 1] --- \

Джерело струму ---<                               >--- Лампочка

                      \ ---> [Транзистор 2] --- /
```

Щоб лампочка загорілася (вихід **1**), струму достатньо пройти хоча б одним із цих шляхів.

- Якщо **Транзистор 1** = "On" (**1**), струм піде через верхній шлях, і лампочка загориться. Неважливо, що відбувається з Транзистором 2.
- Якщо **Транзистор 2** = "On" (**1**), струм піде через нижній шлях, і лампочка загориться.
- Єдиний випадок, коли лампочка не загориться (вихід **0**), — це якщо **обидва** шляхи будуть перекриті, тобто обидва транзистори будуть у стані "Off" (**0**).

Ця фізична поведінка ідеально відтворює математичну логіку "АБО".

**Таблиця істинності для "АБО":**

|Вхід 1 (стан Транзистора 1)|Вхід 2 (стан Транзистора 2)|Вихід (чи горить лампочка)|
|---|---|---|
|0 (Off)|0 (Off)|0 (Не горить)|
|0 (Off)|1 (On)|1 (Горить)|
|1 (On)|0 (Off)|1 (Горить)|
|1 (On)|1 (On)|1 (Горить)|

---

### **Логічний вентиль "НЕ" (NOT) — Інвертор**

**Математичне правило:** Операція "НЕ" — найпростіша. Вона має лише один вхід і просто змінює його на протилежний (інвертує). Якщо на вході **1**, на виході буде **0**, і навпаки.

**Фізична реалізація:** Тут схема трохи хитріша. Вона працює за принципом "перенаправлення" струму. Уявіть її так:

1. Існує постійне джерело струму, підключене до виходу. Тобто, якщо нічого не робити, на виході **завжди** буде **1** (лампочка завжди горить).
2. Наш вхідний сигнал підключений до транзистора, який стоїть не на шляху до лампочки, а на шляху "вбік" — до "землі" (місце, куди стікає струм).

Тепер подивимось, як це працює:

- Коли на вході 0 ("Off"): Транзистор вимкнений і нічого не робить. Струм від джерела спокійно йде до виходу. На виході ми маємо 1. (Вхід 0 -> Вихід 1. Правильно!)
- Коли на вході 1 ("On"): Транзистор вмикається і створює дуже простий шлях для струму, щоб "втекти" на землю. Оскільки струм завжди обирає шлях найменшого опору, він весь іде на землю, а до виходу (до лампочки) не доходить. На виході ми отримуємо 0. (Вхід 1 -> Вихід 0. Правильно!)

Отже, вентиль "НЕ" працює як хитра система дренажу: коли ми подаємо на вхід сигнал "ввімкнути", він не вмикає вихід, а навпаки, вмикає "злив", який забирає весь струм з виходу.

**Таблиця істинності для "НЕ":**

| Вхід 1 (сигнал на транзистор) | Вихід (чи горить лампочка) |
| ----------------------------- | -------------------------- |
| 0 (Off)                       | 1 (Горить)                 |
| 1 (On)                        | 0 (Не горить)              |
Маючи ці три базові вентилі ("І", "АБО", "НЕ"), інженери можуть, наче з конструктора LEGO, зібрати будь-яку, навіть найскладнішу логічну схему, яка і є основою роботи процесора.


### Пам'ять: робочий простір комп'ютера

Якщо процесор — це "мозок", що думає і обчислює, то пам'ять — це його персональний робочий стіл, записник і архів одночасно. Це фізичний компонент, призначений для зберігання будь-якої інформації: від інструкцій для процесора до даних, з якими ці інструкції працюють.

На фундаментальному рівні комп'ютерна пам'ять влаштована як гігантський стелаж із мільйонами крихітних пронумерованих комірок. Кожна така комірка має свою унікальну **адресу**, що дозволяє процесору точно знаходити потрібне місце. В кожній комірці зберігається невеликий обсяг даних, зазвичай один **байт** (вісім бітів). Процесор може виконувати з коміркою дві основні операції: прочитати дані, які вона містить, або записати туди нові дані.

#### Оперативна пам'ять (RAM): швидкість і тимчасовість

Основний тип робочої пам'яті, з якою процесор взаємодіє найчастіше, називається **оперативною пам'яттю**, або **RAM (Random-Access Memory)**. Назва "пам'ять із довільним доступом" означає, що процесор може звернутися до будь-якої комірки з однаковою швидкістю, незалежно від її фізичного розташування. Це наче миттєво телепортуватися до потрібної полиці на стелажі, а не йти вздовж усього ряду.

Головна перевага RAM — це швидкість. Але за неї доводиться платити: оперативна пам'ять є **енергозалежною (волатильною)**. Це означає, що вона зберігає дані лише доти, доки на неї подається живлення. Щойно ви вимикаєте комп'ютер, ваш "робочий стіл" повністю очищується.

#### Ієрархія пам'яті: компроміс між швидкістю та обсягом

У комп'ютері не існує одного ідеального типу пам'яті, який був би одночасно і надшвидким, і величезним за обсягом, і дешевим. Тому інженери використовують багаторівневу систему, або **ієрархію пам'яті**. Принцип простий: що ближче пам'ять до процесора, то вона швидша, менша за обсягом і дорожча.

На вершині цієї ієрархії знаходяться **регістри** — найшвидша пам'ять, вбудована безпосередньо в кристал процесора. Їх обсяг мізерний, але вони потрібні для миттєвих операцій. Сходинкою нижче розташована **кеш-пам'ять**, невеликий, але дуже швидкий буфер між процесором і основною пам'яттю. У кеші зберігаються копії даних та інструкцій, до яких процесор звертається найчастіше, що дозволяє уникнути повільного звернення до RAM. Для кеш-пам'яті зазвичай використовують швидкий тип пам'яті **SRAM (Static RAM)**, яка не потребує постійного оновлення.

Далі йде основний "робочий стіл" системи — **оперативна пам'ять (RAM)**. Її обсяг значно більший, ніж у кешу, але й швидкість доступу нижча. Більшість сучасної RAM — це **DRAM (Dynamic RAM)**, яка потребує постійного електричного оновлення, щоб не втрачати дані. Її підвид, **SDRAM (Synchronous Dynamic RAM)**, працює синхронно з тактовим генератором системи, що значно підвищує швидкість передачі даних.

В основі ієрархії лежить **постійна пам'ять** — довготривалий архів, де інформація зберігається навіть після вимкнення живлення. Ця пам'ять найповільніша, але має найбільший обсяг. До неї належать класичні **жорсткі диски (HDD)**, що використовують магнітний запис, та сучасні **твердотільні накопичувачі (SSD)**, які використовують флеш-пам'ять без рухомих частин, що забезпечує значно вищу швидкість та надійність.

---
### Як пам'ять працює на фізичному рівні: детальний огляд

Хоча мета у всіх типів пам'яті одна — зберігати нулі та одиниці, — фізичні методи, які вони для цього використовують, кардинально відрізняються. Розуміння цих методів пояснює, чому один тип пам'яті швидкий і тимчасовий, а інший — повільний, але постійний.

#### DRAM (оперативна пам'ять): танок зарядів та конденсаторів

В основі кожної комірки пам'яті DRAM лежить крихітна, але елегантна пара компонентів: один **транзистор** та один **конденсатор**.

1.  **Конденсатор** — це мікроскопічний "резервуар" для електричного заряду. Його здатність утримувати заряд і є ключем до зберігання інформації.
2.  **Транзистор** діє як крихітний електронний "вентиль" або "воротар", що контролює доступ до конденсатора.

Процес роботи виглядає так:

* **Запис "1":** Щоб зберегти одиницю, система керування пам'яттю посилає сигнал на транзистор, який "відкриває ворота". Через відкритий транзистор конденсатор миттєво заповнюється електричним зарядом. Після цього транзистор-воротар закривається, і заряд залишається "в пастці" всередині конденсатора.
* **Запис "0":** Щоб зберегти нуль, процес схожий, але тепер транзистор відкривається, щоб дозволити будь-якому заряду, що є в конденсаторі, "втекти", тобто повністю розрядити його. Ворота закриваються, залишаючи конденсатор порожнім.
* **Зчитування:** Щоб перевірити, що зберігається в комірці, система знову відкриває транзистор і дивиться, чи витік з конденсатора якийсь заряд. Якщо так — комірка зберігала **1**, якщо ні — **0**. Цей процес є *руйнівним*, бо під час зчитування конденсатор втрачає свій заряд. Тому одразу після зчитування система має перезаписати значення назад.
* **Оновлення (Refresh):** Конденсатори недосконалі й повільно "протікають", втрачаючи заряд. Саме тому пам'ять називається "динамічною". Щоб запобігти втраті даних, спеціальний контролер пам'яті повинен тисячі разів на секунду пробігатися по всіх комірках і оновлювати їхні заряди. Цей постійний процес оновлення і є однією з причин, чому DRAM споживає енергію і є енергозалежною.

#### HDD (жорсткий диск): магія магнітних полів

Робота жорсткого диска — це диво точної механіки та магнетизму. Його ключові елементи — це **пластина**, що обертається з величезною швидкістю, і **головка для читання/запису**, що рухається над нею.

1.  **Пластина** вкрита тонким шаром феромагнітного матеріалу. Цей шар складається з мільярдів крихітних кристалічних утворень — **магнітних доменів**, кожне з яких можна уявити як мікроскопічну стрілку компаса.
2.  **Головка** — це мініатюрний електромагніт, що може як створювати магнітне поле, так і детектувати його.

Процеси запису та читання відбуваються так:

* **Запис "1" та "0":** Головка пролітає над доріжкою на пластині, що обертається. Щоб записати дані, на котушку головки подається електричний струм. Цей струм створює сильне магнітне поле, яке змінює орієнтацію магнітних доменів під головкою. Змінюючи напрямок струму, головка орієнтує домени в одному з двох напрямків (умовно, "північчю вгору" для **1** і "півднем вгору" для **0**).
* **Зчитування:** Під час зчитування головка не створює поле, а навпаки, є дуже чутливою до нього. Коли вона пролітає над ділянкою з певним магнітним напрямком, це поле індукує в котушці головки слабкий електричний струм. Напрямок цього струму залежить від напрямку магнітного поля. Електроніка комп'ютера вловлює ці зміни струму й інтерпретує їх як послідовність нулів та одиниць.

Повільність HDD зумовлена саме механікою: потрібен час, щоб розкрутити пластину і фізично перемістити головку до потрібної доріжки.

#### SSD (твердотільний накопичувач): електронні пастки

SSD використовують зовсім інший, повністю електронний підхід, заснований на спеціальному типі транзисторів — **транзисторах із плаваючим затвором**.

1.  **Структура комірки:** Кожна комірка пам'яті містить такий транзистор. Його унікальність полягає в наявності додаткового, повністю ізольованого шару, який називається "плаваючим затвором". Цей шар може наче пастка утримувати в собі електрони.

Процеси запису та читання є чисто квантовими та електричними:

* **Запис (Програмування):** Щоб записати, наприклад, **1**, на транзистор подається висока напруга. Ця напруга змушує електрони "протунелювати" крізь тонкий шар ізолятора і застрягти в плаваючому затворі. Оскільки цей затвор повністю ізольований, електрони залишаються в цій пастці навіть після вимкнення живлення.
* **Стирання:** Щоб записати **0**, на комірку подається інша, зазвичай ще вища, напруга, яка "витягує" електрони з пастки, залишаючи плаваючий затвор електрично нейтральним.
* **Зчитування:** Для перевірки стану комірки на неї подається невелика контрольна напруга.
    * Якщо плаваючий затвор **порожній (0)**, транзистор поводиться нормально і пропускає струм.
    * Якщо в плаваючому затворі є **захоплені електрони (1)**, їхній негативний заряд блокує дію контрольної напруги, і транзистор не пропускає струм.

Система детектує, чи пройшов струм, і таким чином розуміє, зберігається в комірці нуль чи одиниця. Відсутність будь-яких рухомих частин робить цей процес неймовірно швидким.


### **Шини: нервова система комп'ютера**

Ми вже знаємо, що процесор постійно спілкується з пам'яттю, читаючи інструкції та обмінюючись даними. Але як саме відбувається цей обмін? За допомогою **шин** — наборів паралельних провідників, які працюють як цифрові магістралі або нервова система, що з'єднує всі ключові компоненти комп'ютера.

Уявіть шину не як один дріт, а як широку багатосмугову дорогу.  Кожна смуга (провідник) може передавати один біт інформації (1 або 0) у вигляді електричного сигналу. Чим ширша шина (чим більше в ній смуг), тим більше даних можна передати одночасно. Існує три основні типи шин, кожна з яких виконує свою унікальну функцію.

- **Шина даних (Data Bus):** Це двостороння магістраль для самих даних.  Коли процесор хоче прочитати щось із пам'яті, дані рухаються по цій шині від RAM до CPU. Коли потрібно щось записати, дані течуть у зворотному напрямку. Ширина цієї шини є дуже важливою: 64-розрядна шина даних може передати 64 біти (або 8 байтів) за один раз, що значно швидше, ніж 32-розрядна.
- **Шина адреси (Address Bus):** Це одностороння вулиця, що веде від процесора до пам'яті.  Перш ніж отримати дані, процесор має вказати, з якої саме комірки пам'яті він їх хоче. Він виставляє унікальну адресу цієї комірки на шину адреси. Контролер пам'яті зчитує цю адресу і готується надати доступ до відповідної комірки. Ширина цієї шини визначає, скільки пам'яті комп'ютер може адресувати.
- **Шина керування (Control Bus):** Якщо шина даних — це вантажівка, а шина адреси — це навігатор, то шина керування — це диспетчер, що віддає накази. По ній процесор надсилає команди, які синхронізують роботу всієї системи.  Це сигнали на кшталт "зараз будемо читати з пам'яті", "зараз будемо записувати в пам'ять" або "дані готові для передачі". Саме ця шина гарантує, що пам'ять і процесор не заважатимуть один одному і будуть діяти злагоджено.

#### **Як відбувається спілкування: простий приклад (читання з пам'яті)**

Щоб уявити цей процес, розглянемо, як процесор читає один байт із пам'яті:

1. **Крок 1:** Процесор розміщує на **шині адреси** унікальний номер комірки, яка йому потрібна.
2. **Крок 2:** Одночасно процесор посилає по **шині керування** сигнал "Memory Read" (Читання з пам'яті).
3. **Крок 3:** Контролер пам'яті отримує адресу та команду. Він знаходить потрібну комірку, копіює дані з неї і виставляє їх на **шину даних**.
4. **Крок 4:** Процесор зчитує дані з шини даних і завантажує їх у один зі своїх внутрішніх регістрів для подальшої обробки.

Весь цей процес відбувається за лічені наносекунди, але саме ця точна і швидка взаємодія трьох шин лежить в основі будь-якої операції у вашому комп'ютері.


### Розділ 2: Архітектурні підходи: Як все поєднати

Тепер, коли ми детально розібралися з основними "цеглинками" комп'ютера — процесором та пам'яттю, — настав час подивитися, як їх можна поєднати в єдину робочу систему. Існують два основні "креслення", або **архітектурні підходи**, які визначають, як саме процесор буде взаємодіяти з пам'яттю. Це архітектури фон Неймана та Гарвардська.

#### Архітектура фон Неймана: один для всіх

Архітектура, запропонована Джоном фон Нейманом, є найпоширенішою і лежить в основі більшості сучасних настільних комп'ютерів та ноутбуків. Її ключовий принцип — **використання єдиного, спільного простору пам'яті як для інструкцій (коду програми), так і для даних**, з якими ця програма працює.

Для обміну інформацією між процесором та єдиним блоком пам'яті використовується спільний набір шин. Такий підхід має одну фундаментальну проблему, відому як **"вузьке місце фон Неймана"**. Оскільки шина даних є спільною, процесор не може одночасно виконувати дві операції: зчитувати з пам'яті наступну інструкцію і зчитувати дані для поточної інструкції. Він змушений робити це послідовно, що створює "затор" і обмежує потенційну швидкість роботи системи.

#### Гарвардська архітектура: кожному своє

Гарвардська архітектура пропонує інше вирішення цієї проблеми. Її основна ідея — **фізичне розділення пам'яті та шин для інструкцій і для даних**.

Таке розділення дає кілька важливих переваг:
* **Одночасний доступ:** Процесор може паралельно зчитувати інструкцію і працювати з даними, що значно прискорює загальний процес виконання програми.
* **Вища продуктивність:** Усунення "вузького місця" дозволяє процесору працювати на повну потужність без зайвих очікувань.
* **Підвищена надійність:** Оскільки код програми зберігається окремо від даних, зменшується ризик того, що помилка в програмі випадково пошкодить або перезапише саму програму.

Через свою ефективність та швидкість, Гарвардська архітектура дуже поширена у спеціалізованих пристроях, таких як цифрові сигнальні процесори та мікроконтролери, де швидкість реакції є критично важливою.

#### **Архітектура фон Неймана: одна дорога для всіх**

Уявіть комп'ютер як промислове містечко, де процесор — це набір заводів, а пам'ять — це центральний склад. В архітектурі фон Неймана всі заводи з'єднані зі складом лише **однією вузькою дорогою**. По цій дорозі курсують вантажівки двох типів: ті, що везуть **креслення** (інструкції для заводів), і ті, що везуть **сировину** (дані).

Оскільки дорога одна, вантажівка з кресленням і вантажівка з сировиною не можуть проїхати одночасно. Це створює постійні затори, відомі як **"вузьке місце фон Неймана"**. Завод змушений чекати на прибуття креслення, перш ніж зможе замовити сировину, і обидва запити потрапляють у той самий потік руху, обмежуючи загальну продуктивність.
#### **Гарвардська архітектура: окремі магістралі**
Гарвардська архітектура модернізує цю логістику. Це містечко, що інвестувало в сучасну транспортну розв'язку. Тут до складу ведуть **дві окремі, паралельні магістралі**:
1. Одна магістраль призначена виключно для транспорту з **кресленнями** (шина інструкцій).
2. Друга — виключно для транспорту з **сировиною** (шина даних).

Такий підхід дозволяє заводу отримувати нове креслення по одній магістралі, в той час як по іншій йому вже доставляють сировину для попереднього завдання. Рух оптимізовано, і продуктивність значно зростає, оскільки процесор може одночасно отримувати і інструкції, і дані.

#### **Економічна доцільність: чому домінує архітектура фон Неймана?**

Виникає логічне питання: якщо Гарвардська архітектура настільки ефективніша, чому в більшості персональних комп'ютерів досі домінує підхід фон Неймана? Відповідь лежить в економіці, гнучкості та сучасному гібридному підході.

1. **Спрощена архітектура та вартість:** Систему з єдиним блоком пам'яті та єдиним набором шин значно простіше і дешевше проектувати та виготовляти. Це вимагає меншої кількості фізичних з'єднань (пінів) на процесорі та простішого розведення доріжок на материнській платі, що здешевлює кінцевий продукт.
2. **Гнучкість використання пам'яті:** Це ключова перевага. В системі фон Неймана пам'ять — це єдиний гнучкий "резервуар". Якщо програма має простий код, але обробляє величезні обсяги даних (наприклад, база даних), вона може використати майже всю пам'ять під дані. І навпаки, програма зі складним кодом, але невеликою кількістю даних, може зайняти більшу частину пам'яті під інструкції. У жорсткій Гарвардській архітектурі з фіксованими обсягами пам'яті для коду та даних це неможливо, що призводить до неефективного використання ресурсів.
3. **Сучасний гібридний підхід:** Насправді, сучасні високопродуктивні процесори не є "чистими" представниками архітектури фон Неймана. Вони використовують **гібридну модель**. На рівні системи (зв'язок процесора з оперативною пам'яттю на материнській платі) вони діють за принципом фон Неймана, зберігаючи гнучкість та дешевизну. Проте**всередині самого кристала процесора** реалізовано Гарвардський підхід: існують роздільні кеші першого рівня для інструкцій (L1i) та для даних (L1d) 2 з окремими внутрішніми шинами. Це дозволяє отримати найкраще з обох світів: швидкість та паралелізм Гарвардської архітектури на мікрорівні, де це найважливіше, та гнучкість і економічність архітектури фон Неймана на макрорівні системи.
--- 
### Розділ 3: Мова Асемблера: пряме спілкування з "залізом"

Після того, як ми розібрали фізичні компоненти комп'ютера та архітектурні "креслення", що їх поєднують, ми готові до останнього кроку — знайомства з мовою, яка дозволяє віддавати прямі, безпосередні накази процесору. Це мова Асемблера.

Асемблер — це мова програмування найнижчого рівня, що стоїть лише на один крок вище від машинного коду, тобто від чистого набору нулів та одиниць. Він використовує прості, зрозумілі людині символічні коди (так звані мнемоніки) для представлення машинних інструкцій. По суті, це міст між світом людей і світом кремнію.

#### Біти, байти та представлення даних

Щоб зрозуміти Асемблер, потрібно спочатку зрозуміти, в якому вигляді комп'ютер бачить інформацію. В основі всього лежить **біт** (binary digit) — найменша одиниця даних. Він може мати лише два значення: 0 або 1. Вся складна логіка та математика комп'ютера зводиться до маніпуляцій з цими бітами.

Біти групуються у **байти**. Один байт — це набір із восьми бітів. Ця одиниця є надзвичайно важливою, оскільки в одному байті можна закодувати один текстовий символ, невелике число або частину більшого об'єкта, наприклад, зображення. Здатність процесора одночасно обробляти певну кількість біт (8, 16, 32 чи 64) визначає його "розрядність" або архітектуру. Цей параметр історично впливав на все: від простоти графіки в 8-бітних ігрових консолях до кінематографічних можливостей сучасних 64-бітних систем.

#### Структура програми на Асемблері

Програма на Асемблері зазвичай має чітку структуру, що складається з кількох секцій.

* **Секція `.data`**: У цьому розділі оголошуються дані, які мають певне початкове значення. Наприклад, тут можна визначити рядок тексту, який програма має вивести на екран. Змінній присвоюється ім'я, тип (наприклад, `db` для байта або `dd` для 32-бітного слова) та конкретне значення.
* **Секція `.bss`**: У цей розділ поміщаються неініціалізовані змінні. Тут ми не даємо змінній конкретного значення, а лише резервуємо для неї місце в пам'яті певного розміру (наприклад, `resb` для резервування байтів). Значення таким змінним будуть присвоєні вже під час виконання програми.
* **Секція `.text`**: Це головна секція, що містить безпосередньо код програми — послідовність інструкцій, які має виконати процесор. Вона зазвичай починається з директиви `global main` та мітки `main:`, які позначають точку входу, з якої почнеться виконання програми.

#### Огляд базових інструкцій: приклад "Hello, World!"

Розглянемо, як ці секції працюють разом на простому прикладі виведення тексту "hello, world".

```
section .data
    msg db "hello, world", 0

section .text
    global main
main:
    mov rax, 1
    mov rdi, 1
    mov rsi, msg
    mov rdx, 12
    syscall

    mov rax, 60
    mov rdi, 0
    syscall
```
### Детальне покрокове пояснення коду "Hello, World!"

Цей код є канонічним прикладом, що демонструє базові принципи взаємодії програми з операційною системою на найнижчому рівні. Давайте розберемо кожну директиву та інструкцію, щоб зрозуміти їхню роль.

#### **Підготовчі секції**

Перед тим, як писати основну логіку, програма має визначити дані, з якими вона буде працювати, та позначити, де саме знаходиться виконуваний код.

Директива `section .data` оголошує початок "секції даних". У цій частині програми ми розміщуємо всі змінні, які мають отримати певні значення ще до запуску. Коли асемблер буде створювати виконуваний файл, він виділить для цих даних спеціальну область у пам'яті і одразу заповнить її. Рядок `msg db "hello, world", 0` є прикладом такого оголошення. Тут `msg` — це символічне ім'я (мітка), яке ми присвоюємо адресі в пам'яті, щоб звертатися до даних простіше. Директива `db` (Define Byte) вказує, що ми резервуємо пам'ять під дані, де кожен елемент має розмір в один байт. Далі йде сам рядок, кожен символ якого буде перетворений на відповідний ASCII-код, а нульовий байт `, 0` додається як стандартний маркер кінця рядка.

Далі, директива `section .text` оголошує початок "секції коду". Саме тут буде знаходитись логіка нашої програми у вигляді послідовності інструкцій для процесора. Щоб операційна система знала, звідки починати виконання, ми використовуємо директиву `global main`, яка робить мітку `main` видимою для компонувальника. Сама мітка `main:` позначає точку входу в програму, після якої починається основний код.

#### **Логіка програми: Системні виклики**

Наша програма виконує дві дії: виводить текст і завершується. Оскільки обидві ці дії вимагають доступу до ресурсів, якими керує операційна система (ОС), вони реалізуються через механізм **системних викликів (syscall)**. Програма готує запит, вказуючи, що саме вона хоче зробити, а потім просить ядро ОС виконати цю дію. В архітектурі x86-64 (Linux) параметри для системного виклику передаються через регістри процесора.

##### **Перший системний виклик: Виведення тексту на екран**

Для виведення тексту на екран ми готуємо запит на системний виклик `write`. Спочатку команда `mov rax, 1` копіює значення `1` в регістр `rax`. Це необхідно, оскільки саме `rax` використовується для передачі **номеру системного виклику**, а номер `1` відповідає операції `write`. Наступна інструкція, `mov rdi, 1`, поміщує `1` в регістр `rdi`. Цей регістр передає перший аргумент, яким для `write` є **файловий дескриптор**. Дескриптор `1` зарезервований за стандартним потоком виводу (**stdout**), тобто консоллю.

Далі, за допомогою `mov rsi, msg`, ми копіюємо в регістр `rsi` адресу, на яку вказує наша мітка `msg`. Регістр `rsi` передає другий аргумент — **вказівник на дані**, які ми хочемо записати. Нарешті, `mov rdx, 12` завантажує в регістр `rdx` третій аргумент — **кількість байтів**, яку потрібно записати, що відповідає довжині рядка "hello, world".

Після того, як усі параметри підготовлені в регістрах, інструкція `syscall` перериває виконання програми і передає керування ядру ОС. Ядро аналізує значення в регістрах, виконує запит (виводить текст на екран) і повертає керування назад.

##### **Другий системний виклик: Завершення програми**

Після виведення тексту програма має коректно завершити свою роботу. Для цього готується новий системний виклик. Інструкція `mov rax, 60` завантажує в `rax` число `60`, що є номером системного виклику `exit` (вихід). В регістр `rdi` за допомогою команди `mov rdi, 0` поміщається **код завершення програми**. За стандартом, `0` означає успішне завершення без помилок. Остання команда `syscall` знову передає керування операційній системі, яка, бачачи запит на вихід, коректно припиняє процес програми.

### Як виконати програму на Асемблері

Коли ми пишемо код на Асемблері, ми створюємо текстовий файл, зрозумілий для нас, але не для процесора напряму. Щоб перетворити цей код на програму, яку операційна система може завантажити і виконати, потрібно пройти двоетапний процес: **асемблювання** та **компонування (лінкінг)**.

Спочатку наш текстовий файл з кодом (наприклад, `hello.asm`) обробляється спеціальною програмою — **асемблером** (наприклад, `nasm`). Асемблер переводить кожну мнемонічну інструкцію (`mov`, `syscall` тощо) у відповідний їй машинний код — послідовність нулів та одиниць. Результатом цього етапу є так званий **об'єктний файл** (наприклад, `hello.o`). Цей файл вже містить машинний код, але ще не є повноцінною програмою. Йому бракує інформації про те, як взаємодіяти з операційною системою.

На другому етапі в гру вступає інша програма — **компонувальник**, або **лінкер** (наприклад, `ld`). Він бере наш об'єктний файл і "зв'язує" його з необхідними системними бібліотеками, завершуючи формування програми. Лінкер розставляє всі фінальні адреси та створює повноцінний **виконуваний файл**, який вже можна запустити. 
### Робота з NASM у WSL (Windows Subsystem for Linux)

Використання WSL — це потужний спосіб отримати доступ до інструментів розробки Linux, таких як NASM, без необхідності встановлювати окрему операційну систему. Ви будете працювати у справжньому терміналі Linux, інтегрованому у ваше середовище Windows.

#### **Крок 1: Встановлення WSL та дистрибутива Linux**

Якщо у вас ще не встановлено WSL, Microsoft зробила цей процес максимально простим.

1. Відкрийте **PowerShell** або **Командний рядок (`cmd`)** від імені адміністратора (правою кнопкою миші на меню "Пуск" -> "Windows PowerShell (Адміністратор)").
2. Введіть і виконайте одну команду:
    ```
   wsl --install
    ```
3. Ця команда автоматично завантажить і встановить останню версію WSL, а також стандартний дистрибутив Linux — **Ubuntu**.
#### **Вирішення поширених проблем: Помилка віртуалізації**

Якщо після виконання команди `wsl --install` ви отримали помилку, що містить текст `WSL2 is not supported...` або `Please enable the "Virtual Machine Platform"`, це означає, що вашій системі потрібно увімкнути спеціальні компоненти для віртуалізації. Ось як це виправити.

**Крок 1.1: Увімкнення компонентів Windows**

1. Переконайтесь, що у вас відкрито **PowerShell від імені адміністратора**.
2. Виконайте наступну команду, щоб увімкнути Платформу віртуальної машини:
    ```
   dism.exe /online /enable-feature /featurename:VirtualMachinePlatform /all /norestart
    ```

3. Далі виконайте команду для увімкнення Платформи гіпервізора Windows:

    ```
   dism.exe /online /enable-feature /featurename:HypervisorPlatform /all /norestart
    ```


**Крок 1.2: Увімкнення віртуалізації в BIOS/UEFI**

Цей параметр дозволяє вашому процесору використовувати технологію віртуалізації.

1. **Перезавантажте комп'ютер**.
2. Під час запуску комп'ютера увійдіть до налаштувань BIOS/UEFI. Для цього потрібно натискати певну клавішу одразу після ввімкнення (зазвичай це **F2**, **F10**, **Del** або **Esc**). Конкретна клавіша залежить від виробника вашого комп'ютера або материнської плати.
3. У налаштуваннях BIOS/UEFI знайдіть розділ "CPU Configuration", "Advanced" або "Security".
4. Знайдіть опцію з назвою **Intel Virtualization Technology (VT-x)**, **AMD-V** або **SVM Mode** і переконайтеся, що вона встановлена в стан **Enabled** (Увімкнено).
5. Збережіть зміни та вийдіть з BIOS/UEFI (зазвичай опція "Save and Exit"). Комп'ютер перезавантажиться ще раз.

Після виконання цих кроків знову відкрийте PowerShell від імені адміністратора і повторіть команду `wsl --install`.

**Крок 1.3: Подальші кроки після встановлення**

1. Після завершення процесу **перезавантажте комп'ютер**. Це обов'язково для завершення налаштування.
2. При першому запуску Ubuntu після перезавантаження система попросить вас створити ім'я користувача та пароль. Це будуть ваші облікові дані для середовища Linux, вони не пов'язані з вашим паролем Windows.

#### **Крок 2: Встановлення NASM та інструментів для компонування**

Тепер, коли у вас є повноцінне середовище Linux, ви можете встановлювати програми за допомогою його пакетного менеджера `apt`.

1. Відкрийте ваш дистрибутив Linux (наприклад, "Ubuntu") через меню "Пуск". Відкриється вікно терміналу.
2. Спочатку оновіть список доступних пакетів. Це гарна практика перед будь-яким встановленням. Введіть команду і введіть свій пароль, який ви створили на попередньому кроці:
    ```
   sudo apt update
    ```

3. Тепер встановіть NASM:
    ```
   sudo apt install nasm
    ```

4. Окрім асемблера, нам потрібен компонувальник (`ld`). Він є частиною набору інструментів `build-essential`, який містить все необхідне для компіляції програм. Встановіть його:

    ```
   sudo apt install build-essential
    ```

#### **Крок 3: Перевірка встановлення**

Переконайтесь, що все встановлено коректно. У тому ж терміналі введіть:

```
nasm -v
```

Ви повинні побачити версію встановленого NASM.

#### **Крок 4: Створення та компіляція програми**

Тепер ви можете створювати та компілювати файли безпосередньо в середовищі Linux.

1. **Робота з файлами:** Файлова система Linux у WSL інтегрована з Windows. Ваші диски Windows доступні за шляхом `/mnt/`. Наприклад, диск `C:` знаходиться за адресою `/mnt/c/`. Однак найпростіше працювати безпосередньо у вашій домашній директорії Linux. Вона доступна за замовчуванням при відкритті терміналу (шлях `~/`).
2. **Створіть файл програми:**
3. Вставте у вікно редактора ваш код "Hello, World!". .
4. **Скомпілюйте та запустіть програму:** Тепер виконайте ті самі команди, що ми розглядали раніше, але вже в терміналі Linux.
    ```
    # Етап 1: Асемблювання
    nasm -f elf64 -o hello.o hello.asm
    
    # Етап 2: Компонування
    ld -o hello hello.o
    
    # Етап 3: Запуск
    ./hello
    ```

5. Після виконання останньої команди ви побачите в терміналі результат роботи вашої програми: `hello, world`.

Ви успішно налаштували повноцінне середовище для низькорівневої розробки на Linux, не виходячи з Windows.****